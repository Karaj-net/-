#Phython 
# ООП в Python
### Подробное объяснение ООП в Python

#### 1. Основные концепции ООП
**Объектно-ориентированное программирование (ООП)** - парадигма программирования, основанная на концепции "объектов", которые содержат:
- **Данные** (атрибуты, поля, свойства)
- **Поведение** (методы, функции)

**Четыре столпа ООП:**
1. **Инкапсуляция** - объединение данных и методов в единую сущность, сокрытие внутренней реализации
2. **Наследование** - создание новых классов на основе существующих
3. **Полиморфизм** - способность объектов с одинаковым интерфейсом иметь разную реализацию
4. **Абстракция** - создание упрощенных моделей реальности

#### 2. Классы и объекты
**Класс** - шаблон для создания объектов, определяющий:
- Атрибуты (переменные класса)
- Методы (функции класса)

**Объект** - конкретный экземпляр класса

```python
# Создание класса
class Dog:
    # Атрибут класса (общий для всех экземпляров)
    species = "Canis familiaris"
    
    # Конструктор (инициализатор)
    def __init__(self, name, age):
        # Атрибуты экземпляра
        self.name = name
        self.age = age
    
    # Метод экземпляра
    def bark(self):
        return f"{self.name} говорит: Гав!"

# Создание объектов (экземпляров класса)
dog1 = Dog("Бобик", 3)
dog2 = Dog("Шарик", 5)

print(dog1.bark())  # Бобик говорит: Гав!
print(dog2.species)  # Canis familiaris
```

#### 3. Конструктор `__init__` и `self`
- `__init__` - специальный метод, вызываемый при создании нового объекта
- `self` - ссылка на текущий экземпляр класса (аналог `this` в других языках)
- Все методы класса первым параметром принимают `self`

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.area = self.calculate_area()
    
    def calculate_area(self):
        return self.width * self.height

rect = Rectangle(4, 5)
print(rect.area)  # 20
```

#### 4. Инкапсуляция и управление доступом
Python использует соглашения для обозначения уровня доступа:
- Публичные члены: `name`
- Защищенные члены: `_name` (соглашение, не строгое ограничение)
- Приватные члены: `__name` (искажение имени)

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner          # публичный атрибут
        self._account_number = self._generate_account_number()  # защищенный
        self.__balance = balance    # приватный атрибут
    
    def _generate_account_number(self):  # защищенный метод
        return "ACC" + str(hash(self.owner))[:8]
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return amount
        return 0
    
    def get_balance(self):  # публичный метод для доступа к приватному атрибуту
        return self.__balance

account = BankAccount("Иван Иванов", 1000)
account.deposit(500)
account.withdraw(200)
print(account.get_balance())  # 1300
# print(account.__balance)  # Ошибка! AttributeError
```

#### 5. Свойства (Properties)
Для контролируемого доступа к атрибутам используются свойства:

```python
class Temperature:
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("Температура ниже абсолютного нуля!")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        return (self._celsius * 9/5) + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        self._celsius = (value - 32) * 5/9

temp = Temperature(25)
print(temp.fahrenheit)  # 77.0
temp.fahrenheit = 100
print(temp.celsius)     # 37.777...
```

#### 6. Наследование
Создание нового класса на основе существующего:

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        raise NotImplementedError("Подклассы должны реализовать этот метод")

class Dog(Animal):
    def speak(self):
        return f"{self.name} говорит Гав!"

class Cat(Animal):
    def speak(self):
        return f"{self.name} говорит Мяу!"

animals = [Dog("Бобик"), Cat("Мурка")]
for animal in animals:
    print(animal.speak())
```

#### 7. Полиморфизм
Объекты разных классов могут использоваться через общий интерфейс:

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle:
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2

shapes = [Rectangle(4, 5), Circle(3)]
for shape in shapes:
    print(f"Площадь фигуры: {shape.area()}")
```

#### 8. Абстрактные классы
Для определения интерфейса без реализации:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass

class Square(Shape):
    def __init__(self, side):
        self.side = side
    
    def area(self):
        return self.side ** 2
    
    def perimeter(self):
        return 4 * self.side

# shape = Shape()  # Ошибка! Нельзя создать экземпляр абстрактного класса
square = Square(5)
print(square.area())  # 25
```

#### 9. Магические методы (Dunder methods)
Специальные методы с двойным подчеркиванием для определения поведения объектов:

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    
    def __len__(self):
        return 2  # Всегда 2 для 2D вектора
    
    def __getitem__(self, index):
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        raise IndexError("Индекс вне диапазона")

v1 = Vector(2, 3)
v2 = Vector(4, 5)
print(v1 + v2)  # Vector(6, 8)
print(v1 == Vector(2, 3))  # True
print(len(v1))  # 2
print(v1[0])    # 2
```

#### 10. Композиция и агрегация
**Композиция** - сильная связь (часть не существует без целого)  
**Агрегация** - слабая связь (часть может существовать отдельно)

```python
# Композиция
class Engine:
    def start(self):
        print("Двигатель запущен")

class Car:
    def __init__(self):
        self.engine = Engine()  # Двигатель создается вместе с автомобилем
    
    def start(self):
        self.engine.start()

# Агрегация
class Wheel:
    def __init__(self, size):
        self.size = size

class Car:
    def __init__(self, wheels):
        self.wheels = wheels  # Колеса передаются извне

wheels = [Wheel(17) for _ in range(4)]
car = Car(wheels)
```

#### 11. Классовые методы и статические методы
- `@classmethod`: работает с классом, а не с экземпляром (первый параметр `cls`)
- `@staticmethod`: обычная функция внутри класса, не получает `self` или `cls`

```python
class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year
    
    @classmethod
    def from_string(cls, date_string):
        day, month, year = map(int, date_string.split("-"))
        return cls(day, month, year)  # Создает новый экземпляр
    
    @staticmethod
    def is_valid_date(day, month, year):
        return 1 <= day <= 31 and 1 <= month <= 12 and year > 0
    
    def __str__(self):
        return f"{self.day:02d}.{self.month:02d}.{self.year}"

date = Date.from_string("15-05-2023")
print(date)  # 15.05.2023
print(Date.is_valid_date(31, 12, 2023))  # True
```

#### 12. Дескрипторы
Для создания управляемых атрибутов:

```python
class PositiveNumber:
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, instance, owner):
        return instance.__dict__[self.name]
    
    def __set__(self, instance, value):
        if value < 0:
            raise ValueError("Значение не может быть отрицательным")
        instance.__dict__[self.name] = value

class Product:
    price = PositiveNumber()
    quantity = PositiveNumber()
    
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity
    
    def total_value(self):
        return self.price * self.quantity

product = Product("Ноутбук", 1000, 5)
# product.price = -500  # ValueError: Значение не может быть отрицательным
```

### Домашнее задание (10 заданий)

**Задача 1: Банковский счет**  
Создайте класс `BankAccount` с атрибутами: владелец, баланс, номер счета. Реализуйте методы:  
- `deposit(amount)`: пополнение счета  
- `withdraw(amount)`: снятие средств (с проверкой баланса)  
- `transfer(other_account, amount)`: перевод на другой счет  
- `__str__()`: строковое представление счета  

**Задача 2: Система бронирования**  
Реализуйте систему бронирования отелей:  
- Класс `Room`: номер (тип, цена, статус: свободен/занят)  
- Класс `Hotel`: содержит номера, методы: бронирование, освобождение, поиск свободных номеров  
- Класс `Client`: клиент (имя, контакты, история бронирований)  

**Задача 3: Фигуры с полиморфизмом**  
Создайте абстрактный класс `Shape` с методами `area()` и `perimeter()`. Реализуйте для:  
- `Circle` (радиус)  
- `Rectangle` (ширина, высота)  
- `Triangle` (стороны a, b, c)  
Создайте функцию, которая принимает список фигур и возвращает суммарную площадь.

**Задача 4: Система управления складом**  
Реализуйте классы:  
- `Product`: товар (ID, название, цена, количество)  
- `Warehouse`: склад (добавление/удаление товаров, поиск по названию, расчет общей стоимости)  
- Используйте композицию/агрегацию  

**Задача 5: Матрицы с магическими методами**  
Создайте класс `Matrix`:  
- Реализуйте операции: `+`, `-`, `*` (матричное умножение)  
- Методы: транспонирование, определитель (для 2x2, 3x3)  
- Поддержка `__getitem__`, `__setitem__` для доступа к элементам  

**Задача 6: Система плагинов**  
Создайте базовый класс `Plugin` с методом `execute()`. Реализуйте несколько плагинов:  
- `TimePlugin`: возвращает текущее время  
- `CalcPlugin`: вычисляет математическое выражение  
- `FilePlugin`: читает содержимое файла  
Реализуйте класс `PluginManager` для регистрации и выполнения плагинов.

**Задача 7: Библиотека с дескрипторами**  
Создайте систему управления библиотекой:  
- Класс `Book`: название, автор, год издания, ISBN (валидация формата)  
- Класс `Reader`: ФИО, номер билета, список взятых книг  
- Класс `Library`: учет книг и читателей, выдача/прием книг  
Используйте дескрипторы для валидации данных.

**Задача 8: Игра "Шахматы"**  
Реализуйте:  
- Абстрактный класс `ChessPiece` с методом `can_move(to_position)`  
- Конкретные фигуры: `Pawn`, `Rook`, `Knight`, `Bishop`, `Queen`, `King`  
- Класс `ChessBoard`: доска 8x8, размещение фигур, проверка ходов  
- Реализуйте специальные правила: рокировка, взятие на проходе  

**Задача 9: ORM-подобная система**  
Создайте систему для работы с БД:  
- Класс `Field`: базовый класс для полей модели  
- Классы `CharField`, `IntegerField`, `BooleanField`  
- Класс `Model`: метакласс для автоматической регистрации полей  
- Класс `Database`: выполнение запросов (CREATE, SELECT, UPDATE, DELETE)  

**Задача 10: Симулятор экосистемы**  
Создайте симулятор экосистемы:  
- Классы организмов: `Plant`, `Herbivore`, `Predator`  
- Характеристики: здоровье, возраст, скорость размножения  
- Поведение: движение, питание, размножение, смерть  
- Класс `Ecosystem`: управление временем симуляции, взаимодействие организмов  

### Ресурсы для изучения
1. **[Официальная документация: классы](https://docs.python.org/3/tutorial/classes.html)**
2. **[Real Python: OOP](https://realpython.com/python3-object-oriented-programming/)**
3. **[Python OOP Tutorial](https://www.youtube.com/playlist?list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc)**
4. **[GeeksforGeeks: OOP Concepts](https://www.geeksforgeeks.org/python-oops-concepts/)**
5. **[Python Descriptors Guide](https://realpython.com/python-descriptors/)**

### Пример решения задачи 1 (Банковский счет)
```python
class BankAccount:
    def __init__(self, owner, balance=0, account_number=None):
        self.owner = owner
        self.__balance = balance
        self.account_number = account_number or self._generate_account_number()
    
    def _generate_account_number(self):
        import uuid
        return str(uuid.uuid4())[:8]
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return amount
        return 0
    
    def transfer(self, other_account, amount):
        withdrawn = self.withdraw(amount)
        if withdrawn:
            other_account.deposit(withdrawn)
            return True
        return False
    
    def get_balance(self):
        return self.__balance
    
    def __str__(self):
        return (f"Счет #{self.account_number}\n"
                f"Владелец: {self.owner}\n"
                f"Баланс: {self.__balance:.2f} ₽")

# Использование
account1 = BankAccount("Иван Иванов", 1000)
account2 = BankAccount("Петр Петров", 500)

account1.deposit(500)
account1.transfer(account2, 300)

print(account1)
print(account2)
```

### Пример решения задачи 3 (Фигуры с полиморфизмом)
```python
from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        return 2 * math.pi * self.radius

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Triangle(Shape):
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
    
    def area(self):
        # Формула Герона
        s = self.perimeter() / 2
        return math.sqrt(s * (s - self.a) * (s - self.b) * (s - self.c))
    
    def perimeter(self):
        return self.a + self.b + self.c

def total_area(shapes):
    return sum(shape.area() for shape in shapes)

# Использование
shapes = [
    Circle(5),
    Rectangle(4, 6),
    Triangle(3, 4, 5)
]

print(f"Общая площадь: {total_area(shapes):.2f}")
```

### Пример решения задачи 8 (Шахматная фигура)
```python
class ChessPiece(ABC):
    def __init__(self, position, color):
        self.position = position
        self.color = color  # 'white' or 'black'
    
    @abstractmethod
    def can_move(self, new_position):
        pass
    
    def __str__(self):
        return f"{self.color} {self.__class__.__name__} at {self.position}"

class Pawn(ChessPiece):
    def can_move(self, new_position):
        # Упрощенная логика для пешки
        x1, y1 = self.position
        x2, y2 = new_position
        
        # Пешки ходят только вперед
        direction = 1 if self.color == 'white' else -1
        
        # Обычный ход: на 1 клетку вперед
        if x1 == x2 and y2 - y1 == direction:
            return True
        
        # Первый ход: на 2 клетки вперед
        start_row = 1 if self.color == 'white' else 6
        if y1 == start_row and x1 == x2 and y2 - y1 == 2 * direction:
            return True
        
        return False

class King(ChessPiece):
    def can_move(self, new_position):
        x1, y1 = self.position
        x2, y2 = new_position
        return abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1

# Пример использования
pawn = Pawn((3, 1), 'white')
king = King((4, 0), 'white')

print(pawn.can_move((3, 2)))  # True
print(pawn.can_move((3, 3)))  # False
print(king.can_move((5, 1)))  # True
```

Эти примеры демонстрируют ключевые аспекты ООП в Python. Практикуйтесь, создавая собственные классы и системы, чтобы глубоко понять концепции объектно-ориентированного программирования.