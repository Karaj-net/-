#Phython 
# Исключения и работа с ошибками
### Подробное руководство по исключениям и обработке ошибок в Python

#### 1. Основы исключений
**Исключение (Exception)** - это событие, возникающее во время выполнения программы, которое нарушает нормальный ход выполнения инструкций. Когда возникает ошибка, Python создает объект исключения, содержащий информацию об ошибке.

**Иерархия исключений:**
```
BaseException
 ├── SystemExit
 ├── KeyboardInterrupt
 ├── GeneratorExit
 └── Exception
      ├── ArithmeticError
      │    ├── ZeroDivisionError
      │    └── FloatingPointError
      ├── LookupError
      │    ├── IndexError
      │    └── KeyError
      ├── OSError
      │    ├── FileNotFoundError
      │    ├── PermissionError
      │    └── IsADirectoryError
      ├── ValueError
      ├── TypeError
      ├── RuntimeError
      └── ... и другие
```

#### 2. Обработка исключений: try/except
Блок `try/except` позволяет перехватывать и обрабатывать исключения.

```python
try:
    # Код, который может вызвать исключение
    result = 10 / int(input("Введите число: "))
except ValueError:
    print("Ошибка: Введите корректное число!")
except ZeroDivisionError:
    print("Ошибка: Деление на ноль невозможно!")
except Exception as e:
    print(f"Произошла непредвиденная ошибка: {type(e).__name__} - {e}")
else:
    print(f"Результат: {result}")
finally:
    print("Блок finally выполняется всегда")
```

**Компоненты:**
- `try`: Блок с потенциально опасным кодом
- `except`: Обработчики конкретных исключений
- `else`: Выполняется, если исключений не было
- `finally`: Выполняется всегда (очистка ресурсов)

#### 3. Генерация исключений: оператор `raise`
Вы можете явно вызывать исключения с помощью `raise`.

```python
def validate_age(age):
    if age < 0:
        raise ValueError("Возраст не может быть отрицательным")
    if age > 120:
        raise ValueError("Слишком большой возраст")
    return age

try:
    user_age = validate_age(-5)
except ValueError as e:
    print(f"Ошибка валидации: {e}")
```

#### 4. Пользовательские исключения
Можно создавать собственные типы исключений, наследуясь от базового класса.

```python
class InvalidEmailError(Exception):
    """Исключение для невалидных email-адресов"""
    def __init__(self, email, message="Некорректный формат email"):
        self.email = email
        self.message = message
        super().__init__(self.message)
    
    def __str__(self):
        return f"{self.email} -> {self.message}"

def validate_email(email):
    if "@" not in email or "." not in email.split("@")[-1]:
        raise InvalidEmailError(email)
    return True

try:
    validate_email("user.example.com")
except InvalidEmailError as e:
    print(e)  # user.example.com -> Некорректный формат email
```

#### 5. Цепочки исключений (Exception Chaining)
Python позволяет связывать исключения для сохранения контекста.

```python
try:
    # Первичная операция
    file = open("data.txt", "r")
except FileNotFoundError as primary_err:
    try:
        # Попытка восстановления
        file = open("backup.txt", "r")
    except FileNotFoundError:
        # Создание нового исключения с сохранением контекста
        raise RuntimeError("Оба файла отсутствуют") from primary_err
```

#### 6. Трассировка стека (Stack Trace)
При перехвате исключения можно получить доступ к трассировке стека.

```python
import traceback

try:
    # Код с ошибкой
    1 / 0
except ZeroDivisionError:
    # Запись трассировки в файл
    with open("error.log", "a") as log_file:
        traceback.print_exc(file=log_file)
    # Или получение в виде строки
    error_trace = traceback.format_exc()
    print(f"Произошла ошибка:\n{error_trace}")
```

#### 7. Ассерты (Assertions)
Ассерты используются для проверки условий во время разработки.

```python
def calculate_discount(price, discount):
    assert price > 0, "Цена должна быть положительной"
    assert 0 <= discount <= 1, "Скидка должна быть между 0 и 1"
    return price * (1 - discount)

# В продакшн-коде ассерты можно отключить флагом -O
# python -O script.py
```

#### 8. Контекстные менеджеры и исключения
Контекстные менеджеры (`with`) гарантируют выполнение очистки ресурсов.

```python
class DatabaseConnection:
    def __enter__(self):
        print("Установка соединения с БД")
        # Здесь может быть код установки соединения
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Закрытие соединения с БД")
        # Обработка исключений внутри контекста
        if exc_type:
            print(f"Ошибка в контексте: {exc_val}")
        # Возврат True подавляет исключение
        return True
    
    def execute_query(self, query):
        print(f"Выполнение запроса: {query}")
        # Имитация ошибки
        if "DROP" in query:
            raise ValueError("Опасный запрос!")

# Использование
with DatabaseConnection() as db:
    db.execute_query("SELECT * FROM users")
    db.execute_query("DROP TABLE users")  # Вызовет исключение, но будет обработано

print("Программа продолжает работу")
```

#### 9. Логирование исключений
Правильное логирование критически важно для диагностики ошибок.

```python
import logging

# Настройка логирования
logging.basicConfig(
    filename='app.log',
    level=logging.ERROR,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

def risky_operation():
    try:
        result = 10 / int(input("Введите делитель: "))
        print(f"Результат: {result}")
    except (ValueError, ZeroDivisionError) as e:
        logging.error(f"Ошибка в risky_operation: {e}", exc_info=True)
        raise

try:
    risky_operation()
except Exception:
    print("Ошибка была залогирована, программа завершает работу")
```

### Домашнее задание (10 заданий)

**Задача 1: Безопасный калькулятор**  
Реализуйте калькулятор, обрабатывающий:
- Деление на ноль
- Нечисловые вводы
- Отрицательные числа для квадратного корня

**Задача 2: Валидатор паролей**  
Создайте функцию, проверяющую сложность пароля. При несоответствии критериям вызывайте исключение `PasswordStrengthError` с детализацией ошибок.

**Задача 3: Файловый менеджер**  
Напишите класс для работы с файлами с обработкой:
- `FileNotFoundError`
- `PermissionError`
- `IsADirectoryError`
Методы: чтение, запись, копирование, удаление.

**Задача 4: Контекстный менеджер для временных файлов**  
Создайте контекстный менеджер, создающий временный файл и автоматически удаляющий его при выходе.

**Задача 5: Обработчик API запросов**  
Напишите функцию для запросов к API с обработкой:
- Таймаутов
- Ошибок HTTP (404, 500)
- Проблем с сетью

**Задача 6: Кастомное исключение для банка**  
Создайте класс `BankAccount` с исключениями:
- `InsufficientFundsError`
- `NegativeAmountError`
- `AccountLockedError`

**Задача 7: Транслятор ошибок**  
Напишите декоратор, перехватывающий исключения и выводящий пользовательские сообщения на русском языке.

**Задача 8: Рекурсия с защитой от переполнения**  
Реализуйте рекурсивный алгоритм с обработкой `RecursionError` и преобразованием его в итеративное решение.

**Задача 9: Система плагинов с обработкой ошибок**  
Создайте систему плагинов, где каждый плагин выполняется в отдельном обработчике ошибок. Основная программа не должна падать из-за ошибок в плагинах.

**Задача 10: Агрегирование ошибок**  
Напишите функцию, выполняющую несколько операций и собирающую все возникшие исключения в составное исключение.

### Ресурсы для изучения
1. **[Официальная документация: исключения](https://docs.python.org/3/tutorial/errors.html)**
2. **[Built-in Exceptions](https://docs.python.org/3/library/exceptions.html)**
3. **[Python Exception Handling](https://realpython.com/python-exceptions/)**
4. **[Logging HOWTO](https://docs.python.org/3/howto/logging.html)**
5. **[Context Managers](https://realpython.com/python-with-statement/)**

### Пример решения задачи 1 (Безопасный калькулятор)
```python
class NegativeRootError(Exception):
    """Ошибка при вычислении квадратного корня из отрицательного числа"""
    def __init__(self, value):
        self.value = value
        super().__init__(f"Квадратный корень из отрицательного числа: {value}")

def safe_calculator():
    try:
        a = float(input("Введите первое число: "))
        operator = input("Введите оператор (+, -, *, /, sqrt): ")
        
        if operator == "sqrt":
            if a < 0:
                raise NegativeRootError(a)
            result = a ** 0.5
        else:
            b = float(input("Введите второе число: "))
            if operator == "+":
                result = a + b
            elif operator == "-":
                result = a - b
            elif operator == "*":
                result = a * b
            elif operator == "/":
                if b == 0:
                    raise ZeroDivisionError("Деление на ноль невозможно")
                result = a / b
            else:
                raise ValueError(f"Неизвестный оператор: {operator}")
        
        print(f"Результат: {result}")
    
    except ValueError as ve:
        print(f"Ошибка ввода: {ve}")
    except ZeroDivisionError as zde:
        print(f"Математическая ошибка: {zde}")
    except NegativeRootError as nre:
        print(f"Ошибка вычислений: {nre}")
    except Exception as e:
        print(f"Непредвиденная ошибка: {type(e).__name__} - {e}")
    finally:
        print("Работа калькулятора завершена")

safe_calculator()
```

### Пример решения задачи 7 (Транслятор ошибок)
```python
def error_translator(func):
    """Декоратор для перевода сообщений об ошибках"""
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except FileNotFoundError:
            raise RuntimeError("Файл не найден") from None
        except PermissionError:
            raise RuntimeError("Нет доступа к файлу") from None
        except ValueError as ve:
            # Специфичная обработка ValueError
            if "invalid literal" in str(ve):
                raise RuntimeError("Некорректное числовое значение") from None
            raise RuntimeError("Ошибка значения данных") from None
        except Exception as e:
            raise RuntimeError(f"Системная ошибка: {type(e).__name__}") from None
    return wrapper

@error_translator
def read_config(file_path):
    with open(file_path, "r") as f:
        return int(f.read().strip())

try:
    value = read_config("config.txt")
    print(f"Значение конфига: {value}")
except RuntimeError as re:
    print(f"Пользовательская ошибка: {re}")
```

### Пример решения задачи 10 (Агрегирование ошибок)
```python
class CompositeError(Exception):
    """Контейнер для нескольких исключений"""
    def __init__(self, errors):
        self.errors = errors
        messages = "; ".join(str(e) for e in errors)
        super().__init__(f"Обнаружено несколько ошибок: {messages}")

    def __str__(self):
        return "\n".join(f"{i+1}. {type(e).__name__}: {e}" for i, e in enumerate(self.errors))

def run_operations(operations):
    errors = []
    
    for operation in operations:
        try:
            operation()
        except Exception as e:
            errors.append(e)
    
    if errors:
        raise CompositeError(errors)

def op1():
    print("Операция 1 выполнена")

def op2():
    raise ValueError("Ошибка в операции 2")

def op3():
    raise FileNotFoundError("Файл для операции 3 не найден")

try:
    run_operations([op1, op2, op3])
except CompositeError as ce:
    print("Сводка ошибок:")
    print(ce)
    print(f"Всего ошибок: {len(ce.errors)}")
```

Эти примеры демонстрируют различные аспекты обработки исключений в Python. Практикуйтесь на заданиях, чтобы закрепить понимание работы с ошибками, что критически важно для создания надежных приложений.