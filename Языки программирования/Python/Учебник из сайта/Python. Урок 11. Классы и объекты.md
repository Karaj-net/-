Данный урок посвящен объектно-ориентированному программированию в _Python_. Разобраны такие темы как создание объектов и классов, работа с конструктором, наследование и полиморфизм в _Python_.
#Уроки_Python 
# Основные понятия объектно-ориентированного программирования

Объектно-ориентированное программирование (ООП) является методологией разработки программного обеспечения, в основе которой лежит понятие класса и объекта, при этом сама программа создается как некоторая совокупность объектов, которые взаимодействую друг с другом и с внешним миром. Каждый объект является экземпляром некоторого класса. Классы образуют иерархии. Более подробно о понятии ООП можно прочитать на [википедии](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

Выделяют три основных “столпа” ООП- это инкапсуляция, наследование и полиморфизм.

## Инкапсуляция

Под инкапсуляцией понимается сокрытие деталей реализации, данных и т.п. от внешней стороны. Например, можно определить класс “холодильник”, который будет содержать следующие данные: производитель, объем, количество камер хранения, потребляемая мощность и т.п., и методы: открыть/закрыть холодильник, включить/выключить, но при этом реализация того, как происходит непосредственно включение и выключение пользователю вашего класса не доступна, что позволяет ее менять без опасения, что это может отразиться на использующей класс «холодильник» программе. При этом класс становится новым типом данных в рамках разрабатываемой программы. Можно создавать переменные этого нового типа, такие переменные называются объекты.

## Наследование

Под наследованием понимается возможность создания нового класса на базе существующего. Наследование предполагает наличие отношения “является” между классом наследником и классом родителем. При этом класс потомок будет содержать те же атрибуты и методы, что и базовый класс, но при этом его можно (и нужно) расширять через добавление новых методов и атрибутов.

Примером базового класса, демонстрирующего наследование, можно определить класс “автомобиль”, имеющий атрибуты: масса, мощность двигателя, объем топливного бака и методы: завести и заглушить. У такого класса может быть потомок – “грузовой автомобиль”, он будет содержать те же атрибуты и методы, что и класс “автомобиль”, и дополнительные свойства: количество осей, мощность компрессора и т.п..

## Полиморфизм

Полиморфизм позволяет одинаково обращаться с объектами, имеющими однотипный интерфейс, независимо от внутренней реализации объекта. Например, с объектом класса “грузовой автомобиль” можно производить те же операции, что и с объектом класса “автомобиль”, т.к. первый является наследником второго, при этом обратное утверждение неверно (во всяком случае не всегда). Другими словами полиморфизм предполагает разную реализацию методов с одинаковыми именами. Это очень полезно при наследовании, когда в классе наследнике можно переопределить методы класса родителя.

# Классы в _Python_

## Создание классов и объектов

Создание класса в _Python_ начинается с инструкции _class_. Вот так будет выглядеть минимальный класс.
```Python
class C:
	pass
```


Класс состоит из объявления (инструкция _class_), имени класса (нашем случае это имя _C_) и тела класса, которое содержит атрибуты и методы (в нашем минимальном классе есть только одна инструкция _pass_).

Для того чтобы создать объект класса необходимо воспользоваться следующим синтаксисом:

**_имя_объекта = имя_класса()_**

### Статические и динамические атрибуты класса

Как уже было сказано выше, класс может содержать атрибуты и методы. Атрибут может быть статическим и динамическим (уровня объекта класса). Суть в том, что для работы со статическим атрибутом, вам не нужно создавать экземпляр класса, а для работы с динамическим – нужно. Пример:
```Python
class Rectangle:
	default_color = "green"
	
	def __init__(self, width, height):
		self.width = width
		self.height = height
```


В представленном выше классе, атрибут _default_color_ – это статический атрибут, и доступ к нему, как было сказано выше, можно получить не создавая объект класса _Rectangle_.
```Python
>>> Rectangle.default_color
'green'
```


_width_ и _height_ – это динамические атрибуты, при их создании было использовано ключевое слово _self_. Пока просто примите это как должное, более подробно про _self_ будет рассказано ниже. Для доступа к _width_ и _height_ предварительно нужно создать объект класса _Rectangle:_
```Python
>>> rect = Rectangle(10, 20)
>>> rect.width
10
>>> rect.height
20
```


Если обратиться через класс, то получим ошибку:
```Python
>>> Rectangle.width
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
AttributeError: type object 'Rectangle' has no attribute 'width'
```

При этом, если вы обратитесь к статическому атрибуту через экземпляр класса, то все будет ОК, до тех пор, пока вы не попытаетесь его поменять. 

Проверим ещё раз значение атрибута _default_color:_
```Python
>>> Rectangle.default_color
'green'
```

Присвоим ему новое значение:
```Python
>>> Rectangle.default_color = "red"
>>> Rectangle.default_color
'red'
```


Создадим два объекта класса _Rectangle_ и проверим, что _default_color_ у них совпадает:
```Python
>>> r1 = Rectangle(1,2)
>>> r2 = Rectangle(10, 20)
>>> r1.default_color
'red'
>>> r2.default_color
'red'
```


Если поменять значение _default_color_ через имя класса _Rectangle_, то все будет ожидаемо: у объектов _r1_ и _r2_ это значение изменится, но если поменять его через экземпляр класса, то у экземпляра будет создан атрибут с таким же именем как статический, а доступ к последнему будет потерян:

Меняем _default_color_ через _r1_:
```Python
>>> r1.default_color = "blue"
>>> r1.default_color
'blue'
```


При этом у _r2_ остается значение статического атрибута:
```Python
>>> r2.default_color
'red'
>>> Rectangle.default_color
'red'
```


Вообще напрямую работать с атрибутами – не очень хорошая идея, лучше для этого использовать свойства.

### Методы класса

Добавим к нашему классу метод. Метод – это функция, находящаяся внутри класса и выполняющая определенную работу.

Методы бывают статическими, классовыми (среднее между статическими и обычными) и уровня класса (будем их называть просто словом метод). Статический метод создается с [декоратором](https://devpractice.ru/python-lesson-19-decorators/) _@staticmethod_, классовый – с декоратором _@classmethod_, первым аргументом в него передается _cls_, обычный метод создается без специального декоратора, ему первым аргументом передается _self:_
```Python
class MyClass:

	@staticmethod
	def ex_static_method():
		print("static method")

	@classmethod
	def ex_class_method(cls):
		print("class method")
	def ex_method(self):
		print("method")
```


Статический и классовый метод можно вызвать, не создавая экземпляр класса, для вызова _ex_method()_ нужен объект:
```Python
>>> MyClass.ex_static_method()
static method

>>> MyClass.ex_class_method()
class method

>>> MyClass.ex_method()
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
TypeError: ex_method() missing 1 required positional argument: 'self'

>>> m = MyClass()
>>> m.ex_method()
method
```


## Конструктор класса и инициализация экземпляра класса

В _Python_ разделяют конструктор класса и метод для инициализации экземпляра класса. Конструктор класса это метод ___new__(cls, *args, **kwargs)_ для инициализации экземпляра класса используется метод ___init__(self)_. При этом, как вы могли заметить ___new___ – это классовый метод, а ___init___ таким не является. Метод ___new___ редко переопределяется, чаще используется реализация от базового класса _object_ (см. раздел Наследование), ___init___ же наоборот является очень удобным способом задать параметры объекта при его создании.

Создадим реализацию класса _Rectangle_ с измененным конструктором и инициализатором, через который задается ширина и высота прямоугольника:
```Python
class Rectangle:

	def __new__(cls, *args, **kwargs):
		print("Hello from __new__")
		return super().__new__(cls)
		
	def __init__(self, width, height):
		print("Hello from __init__")
		self.width = width
		self.height = height
		
>>> rect = Rectangle(10, 20)
Hello from __new__
Hello from __init__

>>> rect.width
10

>>> rect.height
20
```


## Что такое _self_?

До этого момента вы уже успели познакомиться с ключевым словом _self_. _self_ – это ссылка на текущий экземпляр класса, в таких языках как _Java_, _C#_ аналогом является ключевое слово _this_. Через _self_ вы получаете доступ к атрибутам и методам класса внутри него:
```Python
class Rectangle:

	def __init__(self, width, height):
		self.width = width
		self.height = height
		
	def area(self):
		return self.width * self.height
```

В приведенной реализации метод _area_ получает доступ к атрибутам _width_ и _height_ для расчета площади. Если бы в качестве первого параметра не было указано _self_, то при попытке вызвать _area_ программа была бы остановлена с ошибкой.

## Уровни доступа атрибута и метода

Если вы знакомы с языками программирования _Java_, _C#_, _C+_+ то, наверное, уже задались вопросом: “а как управлять уровнем доступа?”. В перечисленных языка вы можете явно указать для переменной, что доступ к ней снаружи класса запрещен, это делается с помощью ключевых слов (_private_, _protected_ и т.д.). В _Python_ таких возможностей нет, и любой может обратиться к атрибутам и методам вашего класса, если возникнет такая необходимость. Это существенный недостаток этого языка, т.к. нарушается один из ключевых принципов ООП – инкапсуляция. Хорошим тоном считается, что для чтения/изменения какого-то атрибута должны использоваться специальные методы, которые называются _getter_/_setter_, их можно реализовать, но ничего не помешает изменить атрибут напрямую. При этом есть соглашение, что метод или атрибут, который начинается с нижнего подчеркивания, является скрытым, и снаружи класса трогать его не нужно (хотя сделать это можно).

Внесем соответствующие изменения в класс _Rectangle_:
```Python
class Rectangle:

	def __init__(self, width, height):
		self._width = width
		self._height = height

	def get_width(self):
		return self._width

	def set_width(self, w):
		self._width = w

	def get_height(self):
		return self._height

	def set_height(self, h):
		self._height = h

	def area(self):
		return self._width * self._height
```


В приведенном примере для доступа к __width_ и __height_ используются специальные методы, но ничего не мешает вам обратиться к ним (атрибутам) напрямую.
```Python
>>> rect = Rectangle(10, 20)
>>> rect.get_width()
10

>>> rect._width
10
```

Если же атрибут или метод начинается с двух подчеркиваний, то тут напрямую вы к нему уже не обратитесь (простым образом). Модифицируем наш класс _Rectangle_:
```Python
class Rectangle:

	def __init__(self, width, height):
		self.__width = width
		self.__height = height

	def get_width(self):
		return self.__width

	def set_width(self, w):
		self.__width = w

	def get_height(self):
		return self.__height

	def set_height(self, h):
		self.__height = h

	def area(self):
		return self.__width * self.__height
```

Попытка обратиться к ___width_ напрямую вызовет ошибку, нужно работать только через _get_width()_:
```Python
>>> rect = Rectangle(10, 20)
>>> rect.__width
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
AttributeError: 'Rectangle' object has no attribute '__width'

>>> rect.get_width()
10
```


Но на самом деле это сделать можно, просто этот атрибут теперь для внешнего использования носит название: __Rectangle__width_:
```Python
>>> rect._Rectangle__width
10

>>> rect._Rectangle__width = 20
>>> rect.get_width()
20
```


## Свойства

Свойством называется такой метод класса, работа с которым подобна работе с атрибутом. Для объявления метода свойством необходимо использовать декоратор _@property_.

Важным преимуществом работы через свойства является то, что вы можете осуществлять проверку входных значений, перед тем как присвоить их атрибутам.

Сделаем реализацию класса _Rectangle_ с использованием свойств:
```Python
class Rectangle:

	def __init__(self, width, height):
		self.__width = width
		self.__height = height

	@property
	def width(self):
		return self.__width

	@width.setter
	def width(self, w):
		if w > 0:
			self.__width = w
		else:
			raise ValueError

	@property
	def height(self):
		return self.__height

	@height.setter
	def height(self, h):
		if h > 0:
			self.__height = h
		else:
			raise ValueError

	def area(self):
		return self.__width * self.__height
```

Теперь работать с _width_ и _height_ можно так, как будто они являются атрибутами:
```Python
>>> rect = Rectangle(10, 20)

>>> rect.width
10

>>> rect.height
20
```

Можно не только читать, но и задавать новые значения свойствам:
```Python
>>> rect.width = 50
>>> rect.width
50

>>> rect.height = 70
>>> rect.height
70
```

Если вы обратили внимание: в _setter_’ах этих свойств осуществляется проверка входных значений, если значение меньше нуля, то будет выброшено исключение _ValueError_:
```Python
>>> rect.width = -10
Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	File "test.py", line 28, in width
		raise ValueError
ValueError
```
## Наследование

В организации наследования участвуют как минимум два класса: класс родитель и класс потомок. При этом возможно множественное наследование, в этом случае у класса потомка может быть несколько родителей. Не все языки программирования поддерживают множественное наследование, но в _Python_ можно его использовать. По умолчанию все классы в _Python_ являются наследниками от _object_, явно этот факт указывать не нужно.

Синтаксически создание класса с указанием его родителя выглядит так:

**_class_ имя_класса(имя_родителя1, [имя_родителя2,…, имя_родителя_n])**

Переработаем наш пример так, чтобы в нем присутствовало наследование:
```Python
class Figure:

	def __init__(self, color):
		self.__color = color

	@property
	def color(self):
		return self.__color

	@color.setter
	def color(self, c):
		self.__color = c

class Rectangle(Figure):

	def __init__(self, width, height, color):
		super().__init__(color)
		self.__width = width
		self.__height = height

	@property
	def width(self):
		return self.__width

	@width.setter
	def width(self, w):
		if w > 0:
			self.__width = w
		else:
			raise ValueError

	@property
	def height(self):
		return self.__height

	@height.setter
	def height(self, h):
		if h > 0:
			self.__height = h
		else:
			raise ValueError

	def area(self):
		return self.__width * self.__height
```

Родительским классом является _Figure_, который при инициализации принимает цвет фигуры и предоставляет его через свойства. _Rectangle_ – класс наследник от _Figure_. Обратите внимание на его метод ___init___: в нем первым делом вызывается конструктор (хотя это не совсем верно, но будем говорить так) его родительского класса:

_super().__init__(color)_

_super_ – это ключевое слово, которое используется для обращения к родительскому классу.

Теперь у объекта класса _Rectangle_ помимо уже знакомых свойств _width_ и _height_ появилось свойство _color:_
```Python
>>> rect = Rectangle(10, 20, "green")

>>> rect.width
10

>>> rect.height
20

>>> rect.color
'green'

>>> rect.color = "red"

>>> rect.color
'red'
```
## Полиморфизм

Как уже было сказано во введении в рамках ООП полиморфизм, как правило, используется с позиции переопределения методов базового класса в классе наследнике. Проще всего это рассмотреть на примере. Добавим в наш базовый класс метод _info()_, который печатает сводную информацию по объекту класса _Figure_ и переопределим этот метод в классе _Rectangle_, добавим  в него дополнительные данные:
```Python
class Figure:

	def __init__(self, color):
		self.__color = color

	@property
	def color(self):
		return self.__color

	@color.setter
	def color(self, c):
		self.__color = c

	def info(self):
		print("Figure")
		print("Color: " + self.__color)

class Rectangle(Figure):

	def __init__(self, width, height, color):
		super().__init__(color)
		self.__width = width
		self.__height = height

	@property
	def width(self):
		return self.__width

	@width.setter
	def width(self, w):
		if w > 0:
			self.__width = w
		else:
			raise ValueError

	@property
	def height(self):
		return self.__height

	@height.setter
	def height(self, h):
		if h > 0:
			self.__height = h
		else:
			raise ValueError

	def info(self):
		print("Rectangle")
		print("Color: " + self.color)
		print("Width: " + str(self.width))
		print("Height: " + str(self.height))
		print("Area: " + str(self.area()))

	def area(self):
	return self.__width * self.__height
```
Посмотрим, как это работает
```Python
>>> fig = Figure("orange")
>>> fig.info()
Figure
Color: orange

>>> rect = Rectangle(10, 20, "green")
>>> rect.info()
Rectangle
Color: green
Width: 10
Height: 20
Area: 200
```


Таким образом, класс наследник может расширять функционал класса родителя.