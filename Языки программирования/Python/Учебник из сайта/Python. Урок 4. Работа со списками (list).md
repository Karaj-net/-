Одна из ключевых особенностей Python, благодаря которой он является таким популярным – это простота. Особенно подкупает простота работы с различными структурами данных – списками, кортежами, словарями и множествами. Сегодня мы рассмотрим **работу со списками**.
#Уроки_Python
## Что такое список (list) в Python?

Список (list) – это структура данных для хранения объектов различных типов. Если вы использовали другие языки программирования, то вам должно быть знакомо понятие массива. Так вот, список очень похож на массив, только, как было уже сказано выше, в нем можно хранить объекты различных типов. Размер списка не статичен, его можно изменять. Список по своей природе является изменяемым типом данных. Про типы данных можно подробно прочитать [здесь](https://devpractice.ru/python-lesson-3-data-model/). Переменная, определяемая как список, содержит ссылку на структуру в памяти, которая в свою очередь хранит ссылки на какие-либо другие объекты или структуры.

## Как списки хранятся в памяти?

Как уже было сказано выше, список является изменяемым типом данных. При его создании в памяти резервируется область, которую можно условно назвать некоторым “контейнером”, в котором хранятся ссылки на другие элементы данных в памяти. В отличии от таких типов данных как число или строка, содержимое “контейнера” списка можно менять. Для того, чтобы лучше визуально представлять себе этот процесс взгляните на картинку ниже. Изначально был создан список содержащий ссылки на объекты 1 и 2, после операции _a[1] = 3_, вторая ссылка в списке стала указывать на объект 3.

![Пример изменяемого объекта](https://devpractice.ru/wp-content/uploads/2016/12/python-lesson3-2-1.png)

Более подробно эти вопросы обсуждались в [уроке 3 (Типы и модель данных)](https://devpractice.ru/python-lesson-3-data-model/).

## Создание, изменение, удаление списков и работа с его элементами

Создать список можно одним из следующих способов.
```Python
>>> a = []
>>> type(a)
<class 'list'>
>>> b = list()
>>> type(b)
<class 'list'>
```

Также можно создать список с заранее заданным набором данных.
```Python
>>> a = [1, 2, 3]
>>> type(a)
<class 'list'>
```


Если у вас уже есть список и вы хотите создать его копию, то можно воспользоваться следующим способом:
```Python
>>> a = [1, 3, 5, 7]
>>> b = a[:]
>>> print(a)
[1, 3, 5, 7]
>>> print(b)
[1, 3, 5, 7]
```
или сделать это так:
```Python
>>> a = [1, 3, 5, 7]
>>> b = list(a)
>>> print(a)
[1, 3, 5, 7]
>>> print(b)
[1, 3, 5, 7]
```

В случае, если вы выполните простое присвоение списков друг другу, то переменной _b_ будет присвоена ссылка на тот же элемент данных в памяти, на который ссылается _a_, а не копия списка _а_. Т.е. если вы будете изменять список _a_, то и _b_ тоже будет меняться.
```Python
>>> a = [1, 3, 5, 7]
>>> b = a
>>> print(a)
[1, 3, 5, 7]
>>> print(b)
[1, 3, 5, 7]
>>> a[1] = 10
>>> print(a)
[1, 10, 5, 7]
>>> print(b)
[1, 10, 5, 7]
```

Добавление элемента в список осуществляется с помощью метода append().
```Python
>>> a = []
>>> a.append(3)
>>> a.append("hello")
>>> print(a)
[3, 'hello']
```

Для удаления элемента из списка, в случае, если вы знаете его значение, используйте метод remove(x), при этом будет удалена первая ссылка на данный элемент.
```Python
>>> b = [2, 3, 5]
>>> print(b)
[2, 3, 5]
>>> b.remove(3)
>>> print(b)
[2, 5]
```

Если необходимо удалить элемент по его индексу, воспользуйтесь командой _del имя_списка[индекс]_.
```Python
>>> c = [3, 5, 1, 9, 6]
>>> print(c)
[3, 5, 1, 9, 6]
>>> del c[2]
>>> print(c)
[3, 5, 9, 6]
```

Изменить значение элемента списка, зная его индекс, можно напрямую к нему обратившись.
```Python
>>> d = [2, 4, 9]
>>> print(d)
[2, 4, 9]
>>> d[1] = 17
>>> print(d)
[2, 17, 9]
```

Очистить список можно просто заново его проинициализировав, так как будто вы его вновь создаете. Для получения доступа к элементу списка укажите индекс этого элемента в квадратных скобках.
```Python
>>> a = [3, 5, 7, 10, 3, 2, 6, 0]
>>> a[2]
7
```

Можно использовать отрицательные индексы, в таком случае счет будет идти с конца, например для доступа к последнему элементу списка можно использовать вот такую команду:
```Python
>>> a[-1]
0
```

Для получения из списка некоторого подсписка в определенном диапазоне индексов, укажите начальный и конечный индекс в квадратных скобках, разделив их двоеточием.
```Python
>>> a[1:4]
[5, 7, 10]
```
## Методы списков
_**list.append(x)**_-Добавляет элемент в конец списка. Ту же операцию можно сделать так _a[len(a):] = [x]_.
```Python
>>> a = [1, 2]
>>> a.append(3)
>>> print(a)
[1, 2, 3]
```

_**list.extend(L)**_-Расширяет существующий список за счет добавления всех элементов из списка _L_. Эквивалентно команде _a[len(a):] = L_.
```Python
>>> a = [1, 2]
>>> b = [3, 4]
>>> a.extend(b)
>>> print(a)
[1, 2, 3, 4]
```

_**list.insert(i, x)**_-Вставить элемент _x_ в позицию _i_.  Первый аргумент – индекс элемента после которого будет вставлен элемент _x_.
```Python
>>> a = [1, 2]
>>> a.insert(0, 5)
>>> print(a)
[5, 1, 2]
>>> a.insert(len(a), 9)
>>> print(a)
[5, 1, 2, 9]
```

_**list.remove(x)**_-Удаляет первое вхождение элемента _x_ из списка.
```Python
>>> a = [1, 2, 3]
>>> a.remove(1)
>>> print(a)
[2, 3]
```

_**list.pop([i])**_-Удаляет элемент из позиции _i_ и возвращает его. Если использовать метод без аргумента, то будет удален последний элемент из списка.
```Python
>>> a = [1, 2, 3, 4, 5]
>>> print(a.pop(2))
3
>>> print(a.pop())
5
>>> print(a)
[1, 2, 4]
```

_**list.clear()**_-Удаляет все элементы из списка. Эквивалентно _del a[:]_.
```Python
>>> a = [1, 2, 3, 4, 5]
>>> print(a)
[1, 2, 3, 4, 5]
>>> a.clear()
>>> print(a)
[]
```

_**list.index(x[, start[, end]])**_-Возвращает индекс элемента.
```Python
>>> a = [1, 2, 3, 4, 5]
>>> a.index(4)
3
```

_**list.count(x)**_-Возвращает количество вхождений элемента _x_ в список.
```Python
>>> a=[1, 2, 2, 3, 3]
>>> print(a.count(2))
2
```

_**list.sort(key=None, reverse=False)**_
Сортирует элементы в списке по возрастанию. Для сортировки в обратном порядке используйте флаг _reverse=True_. Дополнительные возможности открывает параметр _key_, за более подробной информацией обратитесь к документации.
```Python
>>> a = [1, 4, 2, 8, 1]
>>> a.sort()
>>> print(a)
[1, 1, 2, 4, 8]
```

_**list.reverse()**_-Изменяет порядок расположения элементов в списке на обратный.
```Python
>>> a = [1, 3, 5, 7]

>>> a.reverse()

>>> print(a)

[7, 5, 3, 1]
```

_**list.copy()**_-Возвращает копию списка. Эквивалентно _a[:]_.
```Python
>>> a = [1, 7, 9]
>>> b = a.copy()
>>> print(a)
[1, 7, 9]
>>> print(b)
[1, 7, 9]
>>> b[0] = 8
>>> print(a)
[1, 7, 9]
>>> print(b)
[8, 7, 9]
```
## List Comprehensions
_List Comprehensions_ чаще всего на русский язык переводят как  абстракция списков или списковое включение, является частью синтаксиса языка, которая предоставляет простой способ построения списков. Проще всего работу _list comprehensions_ показать на примере. Допустим вам необходимо создать список целых чисел от _0_ до _n_, где _n_ предварительно задается. Классический способ решения данной задачи выглядел бы так:
```Python
>>> n = int(input())
7
>>> a=[]
>>> for i in range(n):
a.append(i)
>>> print(a)
[0, 1, 2, 3, 4, 5, 6]
```

Использование _list comprehensions_ позволяет сделать это значительно проще:
```Python
>>> n = int(input())
7
>>> a = [i for i in range(n)]
>>> print(a)
[0, 1, 2, 3, 4, 5, 6]
```

или вообще вот так, в случае если вам не нужно больше использовать _n:_
```Python
>>> a = [i for i in range(int(input()))]
7
>>> print(a)
[0, 1, 2, 3, 4, 5, 6]
```
## **_List Comprehensions_** **как обработчик списков**
В языке _Python_ есть две очень мощные функции для работы с коллекциями: _map_ и _filter_. Они позволяют использовать функциональный стиль программирования, не прибегая к помощи циклов, для работы с такими типами как _list_, _tuple_, _set_, _dict_ и т.п. Списковое включение позволяет обойтись без этих функций. Приведем несколько примеров для того, чтобы понять о чем идет речь.

Пример с заменой функции _map_.

Пусть у нас есть список и нужно получить на базе него новый, который содержит элементы первого, возведенные в квадрат. Решим эту задачу с использованием циклов:
```Python
>>> a = [1, 2, 3, 4, 5, 6, 7]
>>> b = []
>>> for i in a:
	b.append(i**2)
>>> print('a = {}\nb = {}'.format(a, b))
a = [1, 2, 3, 4, 5, 6, 7]
b = [1, 4, 9, 16, 25, 36, 49]
```

Та же задача, решенная с использованием _map_, будет выглядеть так:
```Python
>>> a = [1, 2, 3, 4, 5, 6, 7]
>>> b = list(map(lambda x: x**2, a))
>>> print('a = {}\nb = {}'.format(a, b))
a = [1, 2, 3, 4, 5, 6, 7]
b = [1, 4, 9, 16, 25, 36, 49]
```

В данном случае применена _lambda_-функция, о том, что это такое и как ее использовать можете прочитать [здесь](https://devpractice.ru/python-lesson-10-functions-in-python/).

Через списковое включение эта задача будет решена так:
```Python
>>> a = [1, 2, 3, 4, 5, 6, 7]
>>> b = [i**2 for i in a]
>>> print('a = {}\nb = {}'.format(a, b))
a = [1, 2, 3, 4, 5, 6, 7]
b = [1, 4, 9, 16, 25, 36, 49]
```

Пример с заменой функции _filter_.

Построим на базе существующего списка новый, состоящий только из четных чисел:
```Python
>>> a = [1, 2, 3, 4, 5, 6, 7]
>>> b = []
>>> for i in a:
if i%2 == 0:
b.append(i)
>>> print('a = {}\nb = {}'.format(a, b))
a = [1, 2, 3, 4, 5, 6, 7]
b = [2, 4, 6]
```

Решим эту задачу с использованием _filter_:
```Python
>>> a = [1, 2, 3, 4, 5, 6, 7]
>>> b = list(filter(lambda x: x % 2 == 0, a))
>>> print('a = {}\nb = {}'.format(a, b))
a = [1, 2, 3, 4, 5, 6, 7]
b = [2, 4, 6]
```

Решение через списковое включение:
```Python
>>> a = [1, 2, 3, 4, 5, 6, 7]
>>> b = [i for i in a if i % 2 == 0]
>>> print('a = {}\nb = {}'.format(a, b))
a = [1, 2, 3, 4, 5, 6, 7]
b = [2, 4, 6]
```
## Слайсы / Срезы

Слайсы (срезы) являются очень мощной составляющей _Python_, которая позволяет быстро и лаконично решать задачи выборки элементов из списка. Выше уже был пример использования слайсов, здесь разберем более подробно работу с ними. Создадим список для экспериментов:
```Python
>>> a = [i for i in range(10)]
```

Слайс задается тройкой чисел, разделенных запятой: _start:stop:step_. _Start_ – позиция с которой нужно начать выборку, _stop_ – конечная позиция, _step_ – шаг. При этом необходимо помнить, что выборка не включает элемент определяемый _stop_.

Рассмотрим примеры:
```Python
>>> # Получить копию списка
>>> a[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> # Получить первые пять элементов списка
>>> a[0:5]
[0, 1, 2, 3, 4]
>>> # Получить элементы с 3-го по 7-ой
>>> a[2:7]
[2, 3, 4, 5, 6]
>>> # Взять из списка элементы с шагом 2
>>> a[::2]
[0, 2, 4, 6, 8]
>>> # Взять из списка элементы со 2-го по 8-ой с шагом 2
>>> a[1:8:2]
[1, 3, 5, 7]
```

Слайсы можно сконструировать заранее, а потом уже использовать по мере необходимости. Это возможно сделать, в виду того, что слайс – это объект класса _slice_. Ниже приведен пример, демонстрирующий эту функциональность:
```Python
>>> s = slice(0, 5, 1)
>>> a[s]
[0, 1, 2, 3, 4]
>>> s = slice(1, 8, 2)
>>> a[s]
[1, 3, 5, 7]
```
## Типо “_List Comprehensions_”… в генераторном режиме
Есть ещё одни способ создания списков, который похож на списковое включение, но результатом работы является не объект класса _list_, а генератор. Подробно про генераторы написано в “[Уроке 15. Итераторы и генераторы](https://devpractice.ru/python-lesson-15-iterators-and-generators/)“.

Предварительно импортируем модуль _sys_, он нам понадобится:
```Python
>>> import sys
```


Создадим список, используя списковое включение :
```Python
>>> a = [i for i in range(10)]
```

проверим тип переменной _a_:
```Python
>>> type(a)
<class 'list'>
```

и посмотрим сколько она занимает памяти в байтах:
```Python
>>> sys.getsizeof(a)
192
```

Для создания объекта-генератора, используется синтаксис такой же как и для спискового включения, только вместо квадратных скобок используются круглые:
```Python
>>> b = (i for i in range(10))
>>> type(b)
<class 'generator'>
>>> sys.getsizeof(b)
120
```

Обратите внимание, что тип этого объекта _‘generator’_, и в памяти он занимает места меньше, чем список, это объясняется тем, что в первом случае в памяти хранится весь набор чисел от 0 до 9, а во втором функция, которая будет нам генерировать числа от 0 до 9. Для наших примеров разница в размере не существенна, рассмотрим вариант с 10000 элементами:
```Python
>>> c = [i for i in range(10000)]
>>> sys.getsizeof(c)
87624
>>> d = (i for i in range(10000))
>>> sys.getsizeof(d)
120
```

Сейчас уже разница существенна, как вы уже поняли, размер генератора в данном случае не будет зависеть от количества чисел, которые он должен создать.

Если вы решаете задачу обхода списка, то  принципиальной разницы между списком и генератором не будет:
```Python
>>> for val in a:
print(val, end=' ')
0 1 2 3 4 5 6 7 8 9
>>> for val in b:
print(val, end=' ')
0 1 2 3 4 5 6 7 8 9
```

Но с генератором нельзя работать также как и со списком: нельзя обратиться к элементу по индексу и т.п.