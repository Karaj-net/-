# Обобщенный класс с несколькими параметрами
Обобщенный класс можно использовать несколько универсальных параметров. Они обозначаются разными буквами, через запятую и соответствуют разным типам данных 
```C#
class Person3<T, P>
{
	private string name;
	private T info;
	private P id;
	
	public string Name{...}
	public T Info {...}
	public P Id {}
	
	public Person3(string name, T info, P id)
	{
		this.name = name;
		this.info = info;
		this.id = id;
	}
	public void Pr() => Console.Writeline("Студент {0}, инфо {1}, id  {2}", name, info, id)
}


class Program
{
	static void Main()
	{
		Person3<int, string> pr1 = new Person3<int, string>("Иванов", 23, "A5")
	}
}
```

## Типизация при помощи обобщенного класса
В обобщенный класс входит универсальный параметр, при создании экземпляра класса, мы должны для этого параметра указать конкретный тип. Возникает вопрос, можно ли типизировать другим обобщенным классам? Единственное, для этого обобщенного  класса уде должна быть выполнена типизация, то есть мы должны вместо его параметров указывать уже конкретные типы.

Предположим у нас проводится соревнования создадим класс с двумя полями, название организации и участник из этой организации. Участник будет иметь тип Person2. Пока мы опишем класс, где тип участника запишем с помощью универсального параметра
Код:
```C#
class Games<T>
{
	private string name;
	private T member;
	
	public string Name {set {name = value;} get {return name;}}
	public T Member {set {member = value;} get {return member;}}
	
	public Games(string name, T membeer)
	{
		this.name = name;
		this.member = member;
	}
}

class Program
{
	static void Main()
	{
		Games<Person2<int>> g1 = new Games<Person2<int>>("КГАСУ", new Person2<int>("Иванов", 55));
		Console.Writeline("Вуз {0}, студент {1}, инфо {2}", g1.Name, g1.Member.Name, g1.Member.Info)
	}
}
```
## Использование обобщенного параметра в статических членах
Указанный в заголовке класса универсальный параметр, может использоваться и в статических членах, а именно в свойствах и методах. При описании нет отличия от динамических членов. Типизацию можно произвести при инициализации статического поля при помощи свойства. Мы можем выполнить целый ряд типизации для одного и того же поля. Таким образом, статического поле будет содержать целый спектр значений различных типов. Добавим в Person2 статические члены 
```C#
class Games<T>
{
	private string name;
	private T member;
	private static T code;
	
	public string Name {set {name = value;} get {return name;}}
	public T Member {set {member = value;} get {return member;}}
	public static T Code {set {code = value;} get {return code;}}
	
	public Games(string name, T membeer)
	{
		this.name = name;
		this.member = member;
	}
}


class Program
{
	static void Main()
	{
		Games<Person2<int>> g1 = new Games<Person2<int>>("КГАСУ", new Person2<int>                                 ("Иванов", 55));
		Console.Writeline("Вуз {0}, студент {1}, инфо {2}", g1.Name,                                         g1.Member.Name, g1.Member.Info)
		Person2<int>.Code = 7;
		Person2<string>.Code = "A3";
		Person2<char>.Code = 'f';
		Person2<bool>.Code = true;
		Console.Writeline("Для int {0}/n Для int {0}/n)
	}
}
```
## Обобщенные методы
Универсальный параметры могут использоваться для обозначения типов не только для описания класса, но и при описании метода. При этом типизация выполняется при вызове метода 

```C#
class Program
{
	static void F<T>(ref T x, ref T y)
	{
		T z = x;
		x  = y;
		y = z;
	}
	static void Main()
	{
		int a = 5;
		int b = 6;
		F(ref a, ref b);
		Console.Writeline("a = {0}, b = {1}", a, b);
		
		string u = ...
	}
}
```
# Наследование обобщенных классов
Рассмотрим вопрос о наследовании. У нас есть класс с универсальными параметрами. Рассмотрим дочерние классы, здесь возможны разные варианты, переберем их. Это мы произведем их. Это мы произведем на примере. В качестве родительского класса используем Person2. Дочерние классы будут иметь дополнительное поле, для которого также будет использоваться универсальный параметр. Дочерние классы будем называть PersonID с некоторым номером.
1. Дочерний класс может иметь тот же самый параметр:
```C#
class PersonId<T> : Person2<T>
{
	private T id;
	private T id { get {return id;}}
	private PersonId1(string name, T info, T id) : base (name, info)
	{
		this.id = id;
	}
}


class Program
{
	static void Main()
	{
		PersonId1<int> pr1 = new PersonId1<int>("Иванов", 53, 7);
	}
}
```

Новое поле вообще может иметь определенный тип
```C#
class PersonId<T> : Person2<T>
{
	private string id;
	private T id { get {return id;}}
	private PersonId1(string name, T info, T id) : base (name, info)
	{
		this.id = id;
	}
}


class Program
{
	static void Main()
	{
		PersonId1<int> pr1 = new PersonId1<int>("Иванов", 53, "A8");
	}
}
```

При описании дочернего класса мы уже можем выполнить типизацию родительского класса. Это указывается непосредственно в заголовке дочернего класса. Таким образом, мы получим, что дочерний класс является обычным классом, необобщенным
```C#
class PersonId<T> : Person2<string>
{
	private string id;
	private T id { get {return id;}}
	private PersonId1(string name, T info, T id) : base (name, info)
	{
		this.id = id;
	}
}


class Program
{
	static void Main()
	{
		PersonId1<int> pr1 = new PersonId1<int>("Иванов", 53, "A8");
	}
}
```
Можно типизировать родительский класс, а для добавить новый обобщенный параметр 
```C#
class PersonId4<T> : Person2<T>
{
	private T id;
	private T id { get {return id;}}
	private PersonId1(string name, T info, T id) : base (name, info)
	{
		this.id = id;
	}
}


class Program
{
	static void Main()
	{
		PersonId1<int> pr1 = new PersonId1<int>("Иванов", 53, "A8");
	}
}
```

