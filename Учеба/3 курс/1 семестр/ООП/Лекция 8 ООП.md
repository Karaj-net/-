# Ограничение обобщения
## 1. Необходимость ограничения 
Типизация универсального параметра можно использовать любой тип, иногда бывает удобно накладывать определенные ограничения. Вспомним, что при описании класса Person2 мы описали или включили, мы не могли записать аналогичный метод и вынуждены были вывод организjвать в классе Program

Ограничения позволяют описать внутри класса, которые в общем случае описать невозможно. Самым простым вариантом ограничением является некоторый класс. Дело в том, что в этом случае при типизации использовать не только его параметры, но и его дочерний класс. Ограничения указываются так:
```C#
class Game1<P> where P: Person2
{
	private string name;
	private P member;
	//свойства
	//конструктор
	public void Pr() => 
	Console.Writeline("Вуз {0}, студент{1}, инфо{2}", name, member.Name, member.Info)
}

static void Main()
{
	Game1<Person2<int>> g1 = new Game1<Person2<int>>("КГАСУ", Person2<int>("Иванов", 95));
	g1.Pr();
}
```

Например, так:
```C#
class Cl1<T, P>
{
	where T: Cl2
	where P: Cl3
}
```
## Стандартные ограничения
Если записать в качестве ограничения какой-то класс, то могут использоваться его дочерние классы
В первом случае можно будет типизировать данными ссылочного типа
Во втором случае значимого типа
В данном случае можно выполнить типизацию любым классом, у которого имеется открытый конструктор без параметров
Некоторый класс может содержать 
Если мы создаем дочерний класс с универсальным параметром, этот параметр также находится в родительском классе и на него есть ограничения. Причем не слабее, чем в родительском. Например, могут быть 
```C#
class Cl1<T> where T: class
{
	тело
}
class Cl2<T>: Cl1<T> where T: Person1
{
	тело
}
```
Ограничения полноценных классов. В воплащенных методах, мы также можем указывать ограничения 
```C#
static void G<T>(T x) where T: Person2
{
	Console.Writeline(x.Name);
}
static void Fcl<T>(ref T x, ref T y) where T: class
{
	T z = x;
	x = y;
	y = z;
}
```
Рассмотрим стандартное ограничение для методов:


