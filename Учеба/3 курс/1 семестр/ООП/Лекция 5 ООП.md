# Абстрактные классы 
Часто используются классы, для которых последствия описываются группы значения классов и в родительском классе бывает невозможно произвести 

Вот такие методы называются абстрактными и сам класс получается абстрактным. Абстрактные методы характеризуются отсутствием реализации, приводится только заголовок и абстрактные класса оснащаются атрибутами abstract мы не сможем создать экземпляр АК, он может использоваться только, как родительский класс в описании других классов. В значениях класса вы должны переопределить эти методы, то есть провести реализацию при этом используется атрибут override. Если все абстрактные методы переопределены значением в классе, то мы получаем обычный начальный класс. И можем создать его экземпляры. 

Заметим , что при создании дочерних классов можем использовать переменные родительского АК

Предположим мы хотим создать класс для работы с геометрическими фигурами. Для нас важными являются значения площадей и периметров. В лучшем случае нет формулы определения данных велечин. Они существуют только для частных случаев фигур, таким образом, опишем класс фигуры с двумя АК, а затем создадим дочерние классы, в которых переопределим методы:
```C#
abstract class Figura
{
	public abstract double Square();
	public abstract double Perimetr();
}

class Triangle: Figure
{
	private double x, y, z;
	
	public Triangle(double z, double y, double z)
	{
		this.x  = x;
		this.y = y;
		this.z = z;
	}
	
	public override double Perimetr => x + y + z;
	public override double Square()
	{
		double p = (x + y + z)/2
		return Math.Sqrt(p*(p-x)*(p-y)*(p-z));
	}
}

class Program
{
	static void Main()
	{
		Figure f1 = new Triangle(3, 4, 5)
		Console.Writeline('Площадь {0}', 'Периметр {1}', f1.Square(), f1.Perimetr());
	}
}
```

Можно в принципе было в родительском классе вообще не указывать в родительском классе, а только в дочернем, но тогда с одной стороны, глядя на родительский класс мы вообще не увидели бы этих методов и не поняли бы связи между дочерними классами, а так мы видим, что во всех значениях этих классов. Другим важным моментом является то, что мы должны были переопределить методы, чтобы их потом использовать 

Рассмотрим 2 пример:
Рассмотрим класс Human с одним полем LastName и абстрактным методом Zarplata. У это класса будет два дочерних класса рабочий и инженер, они отличаются методами, кроме АМ в классе Human опишем обычный метод, который будет выводить информацию о фамилии и зп
```C#
abstract class Human
{
	protected string name;
	public abstract int ZP();
	public void Info()
	{
		Console.Writeline("ФИО {0}, зарплата {1}", name, ZP())
	}
}
class Worker: Human
{
	private int countDay;
	private int tarif;
	public override int ZP() => CountDay*tarif;
	
	public Worker(string name, int counDay, int tarif)
	{
		this.name = name;
		this.countDay = countDay;
		this.tarif = tarif;
	}
}

class Program
{
	static void main()
	{
		Human h1 = Worker;
		h1.Info();
	}
}
```

# Интерфейсы
Интерфейс представляет собой дальнейшее обобщение АК. Интерфейсы состоят только из АМ. При их описании используются ключевое слово interface. Чтобы получить шаблон нужно также в меню выбрать класс, а затем выбрать пункт интерфейс принято имена интерфейс с буквы I модификатор доступа и слово abstruct опускается. Интерфейс может использоваться, как родительским классом. Важным отличием является то, что может быть несколько родительских интерфейсов. Класс может быть дочерним для одного класса и нескольких интерфейсов. Они перечисляются через запятую, сначала записывается класс. 
В отличии от наследования АК при наследовании интерфейсов должны реализовываться все АМ
Также Интерфейсы могут наследовать друг друга и добавлять новые АМ

```C#
interface IFigura
{
	double Square();
	double Perimetr();
}
```

# Использование классов для хранения данных
Иногда удобно данные хранить в специальных классах. Например, в классе Math хранятся значение математических констант.
Суть состоит в следующем, необходимо данные хранить в статических полях без создания экземпляра, чтобы экземпляр невозможно было создать можно описать конструктор без параметров можно написать private, класс без экземпляров можно также описать статические методы, который позволит. Например, мы можем тарифы или оклады работников хранить в статических полях, а затем при приеме на работу выбирать соответствующие тарифы. Методы могут использоваться для индексирования зарплат

Рассмотрим пример:
```C#
class Oklad
{
	private static int oklad = 50000;
	private static int oklad2 = 60000;
	
	pu
}
```