## Абстрактные классы
Часто создаются создаются классы, при которых описывается группа дочерних классов и в родительском классе бывает невозможно привести реализацию метода в общем виде. Хотя в дочерних класса эта задача легко решается. Более того, данный метод бывает актуальным для всех классов. Такие методы называются абстрактными и сам класс получается абстрактным. Абстрактные методы характеризуются тем, что у них отсутствует реализация. Приводится только заголовок. Абстрактные методы и классы оснащаются атрибутом abstract. Мы не может создать экземпляр абстрактного класса. Он может использоваться только как родительский при описании других классов. В значениях классов мы должны переопределить эти методы, то есть привести реализации, при этом используется атрибут override. Если все абстрактные методы родительские классы переопределены, то мы получаем обычный дочерний класс и можем создавать его экземпляры. Если же не все методы переопределены, мы опять получаем абстрактный класс, который может служить только родительским. Заметим, что при создании экземпляров дочернего класса можно использовать переменные родительского абстрактного класса. Предположим, мы хотим создать класс для работы с геометрическими фигурами и для нас важными являются значения площадей и периметр этих фигур. В общем случае нет формулы определения данных величин. Они существуют только для частных видов. Таким образом, опишем класс Figura с 2мя абстрактными методами, а затем создадим дочерние классы, в которых переопределим эти методы. 
Итак, имеем коды:

```C#
abstract class Figura
{
  public abstract 
    double Square();
  public abstract 
    double Perimeter();
}
```

```C#
class Triangle: Figure
{
  private double x,y,z;
  public Triangle(double x, double y, double z)
  {
    this x = x;
    this y = y;
    this z = z;
  }
  public override double Perimeter => x + y + z;
  public override double Square()
  {
    double P = (x + y + z)/2
    rerurn Math.Sqrt(p*(p-x)*(p-y)*(p-z))
  }
}
```

```C#
class Program 
{
  static void Main()
  {
    Figure f1 = new Triangle(3, 4, 5);
    Console.WriteLine("Площадь {0}, периметр {1}",f1.Square(), f1.Perimeter());
  }
}
```
Можно было в родительском классе вообще не указывать абстрактные методы, их ввести только в дочернем, но тогда, с одной стороны, глядя на родительский класс, мы вообще не увидели бы этих методов и не поняли бы связи между дочерними классами, а так мы видим, что во всех этих дочерних классах имеются методы для вычисления площадей и периметров. Другим важным моментом является то, что в дочерних классах для их использования, мы обязательно должны переопределить эти методы. Рассмотрим второй пример. Рассмотрим класс Human с одним полем и абстрактным методом вычисления зарплат. У этого класса будут два дочерних класса, которые отличаются принципом начислений зарплат, кроме абстрактного метода в классе Human опишем обычный метод, который будет выводить информацию о фамилии и зарплате, то есть в теле обычного метода будет использоваться абстрактный метод. 

```C#
abstract class Human
{
  protected string name;
  public abstract int Zarpl();
  public void Info() =>
    Console.WriteLine("Фамилия {0}, зарплата {1}", name, Zarpl());
}
```

```C#
class Worker: Human
{
  private int countDay;
  private int tarif;
  public override int ZarPl => CountDay * tarif;
  public Worker (string name, int CountDay, int tarif)
  {
    this.name = name;
    this.CountDay = CountDay;
    this.tarif = tarif;
  }
}
```

```C#
class Program 
{
  static void Main()
  {
    Human h1 = new Worker("Иванов", 21, 2000);
    h1.Info(); //Иванов, 42000
  }
}
```

## Интерфейсы
Интерфейс представляет собой дальнейшие обобщения абстрактного класса. Интерфейсы состоят только из абстрактных методов. При их описании используется ключевое слово interface. Чтобы получить шаблон, нужно также выбрать в меню "Добавить класс", а затем выбрать пункт "Интерфейс". Принято имена interface начинать с буквы I. При записи абстрактных методов модификатор доступа и слово abstract опускаются. Заметим, что интерфейсы могут выступать в качестве родительских и при создании структур. Важным отличием от наследования класса является то, что может быть несколько родительских интерфейсов. Более того, класс может быть дочерним для одного класса и нескольких интерфейсов. В этом случае они перечисляются через запятую. Первым записывается класс:
class Cl1: Cl2, In1, In2, ...
В отличии от наследования абстрактных классов при наследовании интерфейсов должны реализовываться все абстрактные методы. Интерфейсы также могут наследовать друг друга, добавляя новые абстрактные методы. 

```C#
interface IFigure
{
  double Square();
  double Perimeter();
}
```

## Использование классов для хранения данных
Иногда удобно данные хранить в специальных классах, например, в классе Math хранятся значения математических констант. Рассмотрим варианты:
1. Класс без экземпляров. Суть: необходимые данные мы можем хранить в статических полях, поэтому мы сможем получать к ним доступ без создания экземпляра. Чтобы Экземпляр было невозможно создать, можно описать конструктор без параметров с модификатором private, то есть закрыть конструктор. В классах без экземпляров можно также описать статические методы, которые позволят выполнить определенные процедуры со статическими полями, например, мы можем тарифы или оклады работников хранить в статических полях, а затем при приеме на работу выбирать соответствующий член. Методы могут использоваться для индексирования зарплат. 
```C#
class Oklad
{
  private static int oklad1 = 50000;
  private static inr oklad2 = 60000;
  public static int Oklad1
  {
    return oklad1;
  }
  public static int Oklad2
  {
    return oklad2;
  }
  private Oklad()
  {
    
  }
  public static void Ind(double k)
  {
    oklad1 = (int)(oklad1 * k);
    oklad2 = (int)(oklad2 * k)
  }
}
```

```C#
static void Main()
{
  Ingener h1 = new Ingener("Иванов", ..., oklad.Oklad1);
  Oklad.Ind(1.25);
}
```
