# Дочерние классы
## Наследие 
Создание дочерних классов является одним из основных инструментов ООП. Суть заключается в том, что на основе одних классов создаются другие. При этом исходный класс называется родительским или базовым, а другой дочерним 
Отметим, что все структуры создаются на основе ValueType, для них нет возможности создать дочерний класс. 
Если мы хотим запретить создавать дочерние классы для некоторого класса, мы должны добавить атрибут sealed.
дочерний класс наследует все члены родительского, если мы хотим, чтобы в методах дочернего использовались поля родительского, то в родительском для этих полей нужно использовать protected, а не private.

Пример:
```C#
class Student
{
	//объявление полей
	private string name;
	protected int mat;
	protected int fiz;
	protected int him;
	
	public string Name {get {return name}}
	public double SrBall() => (mat+fiz+him)/3.0;
	
	Student(string name, int mat, int fiz, int him)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
	}
}

//дочерний класс
class StudentIn: Student
{
	private int rus;
	
	StudentIn(string name, int mat, int fiz, int him, int rus)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
		this.rus = rus;
	}
}

class Program
{
	static void Main()
	{
	Student st1 = new Student("Иванов", 5, 4, 4);
	StudentIn st2 = new StudentIn("Боб", 5, 4, 4, 4);
	
	Console.Writline()
	}
}
```

## Полиморфизм
Из предыдущего примера мы видим, что методы дочерних классов в некоторых случаях желательно переопределить, такая возможность имеется, такое свойство называется полиморфизм. Можно в дочернем классе произвести новую реализацию метода, тогда в заголовке метода нужно добавить new. Добавим в дочерний класс метод
```C#
class Student
{
	//объявление полей
	private string name;
	protected int mat;
	protected int fiz;
	protected int him;
	
	public string Name {get {return name}}
	public double SrBall() => (mat+fiz+him)/3.0;
	
	Student(string name, int mat, int fiz, int him)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
	}
}

//дочерний класс
class StudentIn: Student
{
	private int rus;
	
	StudentIn(string name, int mat, int fiz, int him, int rus)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
		this.rus = rus;
	}
	public new SrBall() => (mat+fiz+him+rus)/4.0
}

class Program
{
	static void Main()
	{
	Student st1 = new Student("Иванов", 5, 4, 4);
	StudentIn st2 = new StudentIn("Боб", 5, 4, 4, 4);
	
	Console.Writline()
	}
}
```

## Использование родительского конструктора в дочернем классе 
При создании дочернего класса с конструктором, мы можем использовать аналогичный конструктор родительского класса и приводить только недостающие операторы.
Для этого в заголовке конструктора через двоеточие записываются слово base и в скобках указываются параметры без типа использованные в родительском классе.
Получим следующий конструктор:
```C#
class Student
{
	//объявление полей
	private string name;
	protected int mat;
	protected int fiz;
	protected int him;
	
	public string Name {get {return name}}
	public double SrBall() => (mat+fiz+him)/3.0;
	
	Student(string name, int mat, int fiz, int him)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
	}
}

//дочерний класс
class StudentIn: Student
{
	private int rus;
	
	StudentIn(string name, int mat, int fiz, int him, int rus): base(name, mat, fiz, him)
	{
		this.rus = rus;
	}
	public new SrBall() => (mat+fiz+him+rus)/4.0
}

class Program
{
	static void Main()
	{
	Student st1 = new Student("Иванов", 5, 4, 4);
	StudentIn st2 = new StudentIn("Боб", 5, 4, 4, 4);
	
	Console.Writline()
	}
}
```

## Запись экземпляра дочернего класса в переменную родительский типа
Дочерний класс всегда является более узким, чем родительский, поэтому имеется возможность записать объекты созданные конструктором дочернего класса в переменную родительского класса обратной возможности нет.
```C#
class Student
{
	//объявление полей
	private string name;
	protected int mat;
	protected int fiz;
	protected int him;
	
	public string Name {get {return name}}
	public double SrBall() => (mat+fiz+him)/3.0;
	
	Student(string name, int mat, int fiz, int him)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
	}
}

//дочерний класс
class StudentIn: Student
{
	private int rus;
	
	StudentIn(string name, int mat, int fiz, int him, int rus): base(name, mat, fiz, him)
	{
		this.rus = rus;
	}
	public new SrBall() => (mat+fiz+him+rus)/4.0
}

class Program
{
	static void Main()
	{
	Student st1 = new Student("Иванов", 5, 4, 4);
	StudentIn st2 = new StudentIn("Боб", 5, 4, 4, 4);
	
	Console.Writline()
	
	Student st3 = new StudentIn("Tim", 5, 3, 3, 5);
	}
	
}
```
Если к нему применить некоторый метод, то будет использован метод из родительского класса. Можно этот экземпляр переписать в переменную дочернего класса для этого следует использовать операцию к приведению типа
Например, так:
```C#
class Student
{
	//объявление полей
	private string name;
	protected int mat;
	protected int fiz;
	protected int him;
	
	public string Name {get {return name}}
	public double SrBall() => (mat+fiz+him)/3.0;
	
	Student(string name, int mat, int fiz, int him)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
	}
}

//дочерний класс
class StudentIn: Student
{
	private int rus;
	
	StudentIn(string name, int mat, int fiz, int him, int rus): base(name, mat, fiz, him)
	{
		this.rus = rus;
	}
	public new SrBall() => (mat+fiz+him+rus)/4.0
}

class Program
{
	static void Main()
	{
	Student st1 = new Student("Иванов", 5, 4, 4);
	StudentIn st2 = new StudentIn("Боб", 5, 4, 4, 4);
	
	Console.Writline()
	
	Student st3 = new StudentIn("Tim", 5, 3, 3, 5);
	StudentIn st4 = (StudentIn) st3;
	}
	
}
```
Мы могли привезти тип из того, что изначально объект был создан конструктором дочернего класса. Получили, что результат от зависит переменной(родительская или дочерняя), это может быть неудобным при решении некоторых задач. Уйти от этой зависимости можно используя виртуальные методы

## Виртуальные методы
В этом случае мы также имеем описание метода в родительском и дочернем. В родительском классе добавляется к методу атрибут virtual а в дочернем override
```C#
//родительский класс
class Student
{
	//объявление полей
	private string name;
	protected int mat;
	protected int fiz;
	protected int him;
	
	public string Name {get {return name}}
	public double SrBall() => (mat+fiz+him)/3.0;
	virtual public double SrBall1() => (mat+fiz=him)/
	
	Student(string name, int mat, int fiz, int him)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
	}
}

//дочерний класс
class StudentIn: Student
{
	private int rus;
	
	StudentIn(string name, int mat, int fiz, int him, int rus): base(name, mat, fiz, him)
	{
		this.rus = rus;
	}
	public new SrBall() => (mat+fiz+him+rus)/4.0;
	override public new SrBall() => (mat+fiz+him+rus)/4.0
}

class Program
{
	static void Main()
	{
	Student st1 = new Student("Иванов", 5, 4, 4);
	StudentIn st2 = new StudentIn("Боб", 5, 4, 4, 4);
	
	Console.Writline()
	
	Student st3 = new StudentIn("Tim", 5, 3, 3, 5);
	StudentIn st4 = (StudentIn) st3;
	}
	}
```
В обоих случаях будут использоваться реализация дочернего класса
## Класс System.Object
Все классы, в том числе и пользовательские, создаются на основе класса System.Object, то есть все они являются дочерними по отношению к нему, поэтому они наследуют члены данного класса. Класс System.Object содержит всего 4 метода, таким образом эти методы доступны всем классам
```C#
Eguls() //виртуальный метод, который сравнивает два экземпляра. Второй экземляр передается в виде поле. Если экземпляры находятся на одном участке памяти, то возращается True, если нет, то False
GetType() //возращает тип объекта, то есть название класса
GetHashCode() // возрвращает некоторый код соответствующий экземпляру, это виртуальный метод
ToString() //это виртуальный метод, возращает название класса
```
Данные методы виртуальные. В встроенных классах эти виртуальные методы переопределены. Например, если мы возьмем класс int
```C#
object st5 = new Student("Петров", 4, 5, 4);
object st6 = new Student("Петров", 4, 5, 4);
```