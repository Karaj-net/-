# Коллекции 
## Коллекция List`<T>
Обычно в языках программирования с однотипными данными используют массивы, но в некоторых случаях используют коллекции. Они обладают  соответствующими свойствами и методами и эффективно обрабатывать эти объекты, также отметим, что в коллекции есть возможность добавление членов и удаление
Рассмотрим основные виды коллекции:
Коллекция List соответствует простому списку. Создать коллекцию можно при помощи конструктора на основе некоторого массива или конкретных объектов. Типизация определяет тип объектов, входящих в коллекцию. Мы в качестве примера будем рассматривать экземпляры класса студент. Предположим, что этот класс имеет поля - mat name, fiz, him. Соответствующие методы для ввода и вывода и для вычисления среднего балла и конструктор с параметрами. Отметим, что м

```C# 
Student st1 = new Student("Иввнов", 5, 4, 5);

Student[] stnd = {st1, st2};
List<Student> l1 = new List<Student>(stnd){st3};
Console.Writeline(l1[1].Name); // Петров

l1.Add(st4); //st1, st2, st3,st4
l1.Insert(2, st5); // st1, st2, st5, st3, st4
l1.Insert(4, st1); // st1, st2, st5, st3, st1, st4

foreach (Student x in l1)
	Console.Writeline("студент {0}, средний балл {1}", x.Name, x.SrBall());
	
int k = l1.Count;
for (int i = 0, i < k, i ++)
{
	Console.Writeline("Студент {0}, ср {1}", l1[i].Name, l1[i].SrBall());
}

MoveAt(1); // удаляет по индексу
Move(st5) // удаляет по названию

Contains() //если объект в данном массиве

int n = l1.IndexOf(st1); // 0
int m = l1.LastIndexOf(st1); // 2

l1 = l1.Reverse(); // меняет индексы наоборот
l1 = l1.Clear(); // удаляет всю коллекцию
```

## Коллекция Queue`<T>
Соответствует очереди, которая соответствует FIFO. В этом случае очередной член при добавлении встает на конец очереди, извлекаться члены могут только с начала очереди. Можно создать очередь на основе некоторого массива или другой коллекции. Здесь нет номера, мы не можем работать for только с foreach. Для добавления используется метод Push(). Как мы указали члены могут извлекаться только в начале - это функция Pop(), которая возвращает первый член и убирает из очереди. Peek() показывает, но не удаляет.

```C#
Student st1 = new Student("Иввнов", 5, 4, 5);

Student[] stnd = {st1, ..., st4};
Queue<Student> q1 = new Queue<Student>(st);
Console.Writeline(l1[1].Name); // Петров

q1.Enqueue(st5); // вывод колекции
Degqueue();
Peek();

foreach(Student x in q1)
{
	Console.Writeline("студент {0}, средний балл {1}", x.Name, x.SrBall());
}

while (q1.Count != 0)
{
	Student x = q1.Dequeue();
	Console.Writeline("Фамилия {0}, ср балл {1}", x.Name, x.SrBall())
}
```

## Коллекция Stack`<T>
Аналог очереди работает по аналогии LIFO. Очередной объект размещается в начале очереди, кто последний заходит, тот первым выходит, методы аналогичны последней коллекции
```C#
Student st1 = new Student("Иввнов", 5, 4, 5);

Student[] stnd = {st1, ..., st4};
Stack<Student> q1 = new Stack<Student>(st);
Console.Writeline(l1[1].Name); // Петров

q1.Push(st5); // вывод колекции
Pop();
Peek();

foreach(student x in s1)
{
	Console.Writeline("студент {0}, средний балл {1}", x.Name, x.SrBall());
}
```