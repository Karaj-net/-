# Конструкторы
**Конструкторы** используются при создании нового экземпляра класса. Заметим, что в принципе **конструктор** - это метод специального вида по имени он совпадает с именем класса и у него не указывается изначальный тип

Как и любой метод конструктор может иметь перегрузки, который отличается в данном случае кол-вом параметров. Параметры могут использоваться для начальных инициализаций полей. Если в классе не описан не один конструктор, то он автоматически создается конструктор без параметров. Заметим, если возникает небоходимость использования конструктора без параметров, при наличии другого конструктора, то этот конструктор должен быть описан явно, например, так:
`public Student(){}`

Конструктор может быть статическим. Статический конструктор выполняется только один раз, при первом использовании данного класса. Он может использоваться, например, для инициализации статических полей или вывода каких-то сообщений. 

## Перегрузка операций 
В разрботаном классе можно внести какие-то операции. Есть унарные и бинарные. При создании унарных операций нужно использовать символы предназначенные для унарных, аналогично для бинарных. 

Перегрузка операций выполняется в виде метода и имеет следующую структуру 
```C#
public or static тип оператор символ(параметр) {
	тело
	return
}
```
## Массивы пользовательских объектов
Можно создать некоторое кол-во объектов определенного объекта и из них создать массив. Это можно выполнить с помощью оператора
`тип[] имя = {экземпляры}`
Любой массив является дочерним для класса array, поэтому можно использовать его функциями

Пример:

```C#
class Student
{
	private string name;
	private int mat;
	private int fiz;
	private int him;
	static private int constST;
	
	public string Name
	{
		set {name = value}
		get {return name}
	}
	
	public int Mat {set{mat = value}}
	public int Fiz {set{fiz = value}}
	public int Him {set{him = value}}
	static public int ConstSt {set{constST = value}}
	
	public double SrBall() => (mat + fiz + him)/3.0;
	
	static public int GetCount() => countSt;
	
	static Student()
	{
		Console.Writeline("Класс Student");
	}
	public Student()
	{
		CountST++;
	}
	public Student(string name, int mat, int fiz, int him)
	{
		this.name = name;
		this.mat = mat;
		this.fiz = fiz;
		this.him = him;
		countST++;
	}
	static public Student operator !(student a)
	{
		return new Student(a.name, 5, 5, 5);
	}
	static public  Student operator / (Student a, string x)
	{
		return new Student(x, a.mat, a.fiz, a.him);
	}
}
```


```C#
class Programm
{
	static void main() 
	{
		student.CountST = 0;
		student st1 = new Student();
		
		Console.Writeline(Student.GetCount());
		
		st1.name = 'Ivanov';
		st1.mat = 5;
		st1.fiz = 4;
		st1.him = 4;
		Console.Writeline(st1.SrBall())
		
		student st2 = new Student('Petrov', 5, 5, 4);
		Console.Writeline(st2.SrBall);
		st2 = st2/'Cidorov';
		Console.Writeline('Cidorov {0}, sred ball {1}', st2.Name, st2.SrBall());
		
		st2 = !st2;
		Console.Writeline(st2.SrBall());
		Console.Writeline(Student.GetCount());
		
		student st3 = new Student("Alekseew", 3, 5, 5);
		student st4 = new Student("Popa", 3, 5, 5);
		student st5 = new Student("Yajemat", 3, 5, 5);
		
		student[] sts = {st1, st2, st3, st4, st5};
		
		int s = 0;
		
		for (int k = 0; k < sts.Lenght; k++)
		{
			s += sts(k).Mat;
			double srMat = ((double)s)/sts.Lenght;
		}
		Console.Writeline(srMat);
		
		Console.Writeline(Student.GetCount());
	}
}
```

## Поля, как вложенные классы. Вложенные классы
Вложенные классы на ровне с ... можно использовать типы соответствующие пользовательскими классами. Мы можем использовать поля класса Student, причем если используемый тип применяется только в пределах данного класса, то можно описание класса записать внутри тела использующего класса

Здесь основная проблема возникает при создании экземпляров или в случае использования конструктора с использованием параметров, так как для заполнения поля, необходимо создать экземпляр класса Student, если мы используем конструктор без параметров, тогда поля заполняются с помощью свойства 


```C#
class Games
{
	private string name;
	private student members;
	
	public string Name
	{
		set {name = value;}
		get {return name;}
	}
	
	public string Members
	{
		set {member = value;}
		get {return member;}
	}
	
	public Games() {}
	
	public Games(string name, string name1, int mat, int fiz, int him)
	{
		this.name = name;
		member = new Student(name1, mat, fiz, him);
	}
}
```

