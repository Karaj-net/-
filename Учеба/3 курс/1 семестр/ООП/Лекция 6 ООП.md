## Использование констант
В предыдущем случае мы использовали для хранения данных без экземпляров. Для этого мы создали статические поля и описали свойства для доступа к ним. Если бы мы объявили поля открытыми, то необходимости в свойствах не было бы. Однако возникала опасность возможности изменения значений полей. Этого можно избежать, если использовать константы. Они описываются по аналогии с полями, только их значение изменять нельзя, при это используется ключевое слово const. Чтобы отсутствовала возможность создать экземпляр класса, его можно объявить абстрактным. 

```C#
abstract class AbsTarif
{
  public const int TARIF1 = 2000;
  public const int TARIF2 = 3000;
}
```
Очевидно, это описание гораздо проще. Однако нет возможности индексировать. 

```C#
static void Main()
{
  Worker w1 = new Worker("Иванов", AbsTarif.Tarif1, 21);
}
```

## Перечисления 
Очень часто выбор вариантов используются перечисления. Отметим, что перечисления относятся к значимым типам, поэтому программа с ними работает быстрее. Описание перечислений имеет вид:

```C#
enum имя
{
  значение 1, значение 2, ...
}
```
Значение - это некоторые названия членов перечисления с возможными их значениями. Если значение указано, то этот член принимает указанные значения. Если же значение не указано, то первый член принимает значение 0, а каждый следующий на 1 больше, чем предыдущий. Заметим, что обычно перечисления составляются на основе типа int. Можно использовать другие целочисленные типы и перечисления определяют свой тип. Существует неявное преобразование из int в этот тип. Опишем перечисления:

```C#
enum TarifEnum
{
  tarif1 = 2000,
  tarif2 = 3000
}
Worker w2 = new Worker("Иванов", (int)TarifEnum.tarif1, 21);
```
Все перечисления являются начальными по отношению к классу System.Enum, поэтому наследуют его методы. 


#  РГР2. Обобщения
## Поля для хранения данных заранее известного типа
Предположим, что мы хотим создать класс с 2мя полями. Первое поля для фамилии, второе поле для хранения некоторой информации. Заранее не знаем, какого типа будет информация. В зависимости от типа она может быть использована в разных преобразованиях. Возникает вопрос, какого типа поля описать. Можно использовать тип Object. Рассмотрим соответствующие коды:

```C#
class Person1
{
  private string name;
  private object info;
  public string Name
  {
    get
    {
      return name;
    }
    set
    {
      name = value;
    }
  }
  public object Info
  {
    set
    {
      return info
    }
    set 
    {
      info = value
    }
  }
  public Person1(string name, object info)
  {
    this.name = name;
    this.into = info;
  }
  public void P2 =>
  Console.WriteLine("Студент {0}, into{1}", name, info)
}
```



```C#
class Program
{
  static void Main()
}
Person1 pr1 = new Person1("Иванов", 5);
Person1 pr2 = new Person1("Петров", 5);
Person1 pr3 = new Person1("Сидоров", 'g');
Person1 pr4 = new Person1("Шишел-Мышел", true);
pr1.Pr();
pr2.Pr();
pr3.Pr();
pr4.Pr();
```
Экземпляры всегда создаются для выполнения некоторых преобразований. В качестве преобразования, мы будем использовать сложение для числового типа, отрицание для логического типа, сцепление для строковых.

```C#
pr1.Info = (int) pr1.Info + 1;
pr2.Info = (string) pr2.Info + 1;
pr3.Info = (char) pr3.Info + 1;
pr4.Info = !((bool) pr4.Info);
pr1.Pr(); // Иванов 6
pr2.Pr(); // Петров 51
pr3.Pr(); // Сидоров какое то число
pr4.Pr(); // Шишел-Мышел folse
```
Здесь неожиданно появляется 3 результат. В принципе, таким образом, мы можем добиться необходимых результатов. Однако здесь имеются проблемы. Тип int является значимый, тип object - ссылочный. Получается, что мы значимую величину упаковываем в ссылочный тип. При выполнении действий нужно выполнить распаковку. Если таких действий много, то они будут требовать больших ресурсов. Существует другая проблема, связанная с безопасностью. Предположим, что мы записали ошибочный оператор. Наш ход будет откомпелирован. И ошибка будет выявлена только на этапе выполнения, то есть возникнет исключение. Поэтому такой вариант использования типа objectсчитается нецелесообразным.

## Обобщенный класс
Обобщенные классы характеризуются тем, что в них для обозначения некоторого типа используется универсальный параметр. Этот параметр обычно обозначается прописной буквой и записывается в угловых скобках возле имени. При использовании класса выполняется типизация, то есть определяется какому типу соответствует данный параметр. Вместо параметра записывается этот тип. Заметим, что в одном и том же коде для разных экземпляров могут использоваться разные варианты типизации. Рассмотрим класс:

```C#
class Person2 <T>
{
  private string name;
  private T info;
  public string Name
  {
    get
    {
      return name;
    }
    set
    {
      name = value;
    }
  }
  public T Info
  {
    get
    {
      return info;
    }
    set
    {
      info = value;
    }
  }
  public Person2 (string name, T info)
  {
    this.name = name;
    this.info = info;
  }
  publuc void Pr() =>
  Console.WriteLine("Студент {0}, инфо{1}", name, info)
}
```

```C#
class Program
{
  static void Main()
  {
    Person2 <int> pr1 = new Person2 <int> ("Иванов", 5);
    Person2 <string> pr2 = new Person2 <string> ("Петров", "5");
    Person2 <char> pr3 = new Person2 <char> ("Сидоров", 'g');
    Person2 <bool> pr4 = new Person2 <bool> ("Шарапов", true);
    pr1.Pr();
    pr2.Pr();
    pr3.Pr();
    pr4.Pr();
    pr1.Info = pr1.Info + 1;
    pr2.Info = pr2.Info + 1;
    pr3.Info = (char)(pr3.Info + 1);
    pr4.Info = ! pr4.Info;
    pr1.Pr();
    pr2.Pr();
    pr3.Pr();
    pr4.Pr();
  }
}
```