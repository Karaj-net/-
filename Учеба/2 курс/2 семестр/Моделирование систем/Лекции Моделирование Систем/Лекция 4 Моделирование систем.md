#Моделирование_систем 
24.02.2025
# Отношения в системе классов
### Виды отношений
Отношения между классами на диаграмме представляются следующими соединительными линиями:
![[Pasted image 20250301220710.png]]

#### Отношение ассоциации
Отношение ассоциации используют, чтобы показать, что между классами (например, между двумя классами) существует некоторая связь. Обычно с помощью него на диаграмме классов показывают, что один класс пользуется функционалом другого класса.
![[Pasted image 20250301221034.png]]
Методы класса LogSystem используют метод Console:WriteLine() и, возможно, некоторые другие для вывода результатов.

В общем случае, использование отношения ассоциации выглядит следующим образом:
![[Pasted image 20250301222639.png]]

Как вы можете заметить, стрелка ассоциации направлена от класса *пользователя* к классу *владельцу* используемой функциональности. Для пояснения того, каким образом один класс использует другой класс, вы можете описать данный процесс в *вспомогательном тексте*.

Обратите внимание на *кратность ассоциации*, которая расположена под стрелкой. С кратностью мы уже встречались ранее. Здесь у нее несколько иное значение. Кратность ассоциации обозначает количество объектов, которые участвуют во взаимодействии. Как показано на рисунке выше, во взаимодействии могут участвовать от m до n пользователей и от q до r владельцев.
![[Pasted image 20250301223838.png]]
Клиенты могут подключаться к серверу. С помощью кратности ассоциации указывается допустимое количество объектов в таком взаимодействии.

Если кратность ассоциации не указана, будет подразумеваться кратность [0..* ]. В случае со статическими классами кратность не указывается (можно считать, что там указана кратность. 

Избегайте использования отношения ассоциации в обе стороны, как это показано на рисунке ниже. Такое взаимодействие классов можно считать ярким примером спагетти-кода. В случае ошибки очень сложно будет обнаружить, что послужило ей причиной.

![[Pasted image 20250302003345.png]]
Обозначение отношения ассоциации
![[Pasted image 20250302003414.png]]
С помощью отношения ассоциации мы в общих чертах показываем, как взаимодействуют классы.

####  Отношение зависимости
Отношение зависимости используют, чтобы показать, что изменение одного класса требует изменение другого класса. Стрелка отношения зависимости направлена от зависимого класса к независимому.

#### Отношение наследования
Как вы можете видеть, данное отношение имеет два названия: отношение обобщения и отношение наследования. В терминах ООП принцип наследования является очень важной вещью. Чтобы не вносить путаницу в дальнейшее повествование, давайте договоримся использовать только второе название – отношение наследования – применительно к диаграмме классов.

Итак, отношение наследования используется, чтобы показать, что один класс является родителем (базовым классом или суперклассом) для другого класса (потомка, производного класса).
![[Pasted image 20250302003722.png]]
Если вы работали с какой-нибудь библиотекой для создания графического интерфейса, вы могли заметить, что все классы графических элементов обычно выстраиваются в цепочку наследования. Например, взгляните на цепочку наследования классов фреймворка Qt5, представленную на рисунке ниже.
![[Pasted image 20250302004136.png]]
Отношение наследования здесь изображается обычной стрелкой. Полная версия диаграммы

Разумеется, такие цепочки наследования просто необходимы, поскольку различные виджеты (графические элементы) имеют схожие свойства и поведение.

#### Отношение агрегации
Отношение агрегации между двумя классами показывает, что один из них включает в себя другой класс в качестве составной части. При этом класс часть **может и существовать обособленно** от класса-целого.
![[Pasted image 20250302004406.png]]
В переводе с английского, слово aggregation означает соединение частей. Это значение очень точно отражает суть данного отношения – показать, из каких частей состоит класс. Отношение означает, что объект одного класса включает в себя в качестве составной части объект другого класса.
![[Pasted image 20250302004556.png]]
Объект класса PersonalComputer (упрощённо) состоит из объекта класса Monitor, объекта класса ComputerMouse и объекта класса Keyboard.

С отношением агрегации также можно использовать кратность, чтобы показать, сколько объектов одного класса входят в состав объекта другого класса.

#### Отношение композиции 
Отношение композиции является частным случаем отношения агрегации. Однако у него есть одно отличие – классы-части, которые он соединяет с классом-целым, **не могут существовать обособленно.**

Одним из переводов слова composition является слово **смесь**. Если допустить, что из смеси не получится получить исходные компоненты, то это хорошо помогает понять, что части, соединённые отношением композиции не могут существовать сами по себе.

Давайте в качестве примера рассмотрим окно интерпретатора Python.
![[Pasted image 20250302004833.png]]
Понятное дело, что ни полоса прокрутки (ScrollBar), ни заголовок окна (Title), ни поле ввода команд (TextInput) не могут существовать отдельно от окна программы (Window). Это можно изобразить на диаграмме классов следующим образом.
![[Pasted image 20250302004857.png]]

### Выявление классов
Выявление классов можно начать с изучения потока событий. Имена существительные в описании этого потока дадут понять, что может являться классом. В общем случае существительное может оказаться действующим лицом, классом, атрибутом класса или выражением, не являющимся ни действующим лицом, ни классом, ни атрибутом класса.

Если в ходе проектирования системы Вы уже построили диаграммы взаимодействия, перед тем, как приступать к построению диаграмм классов, то ищите на этих диаграммах похожие объекты. Например, у Вас может быть диаграмма последовательности, описывающая оформление заказа объектами Ивановым и Петровым. Обратите внимание на эти объекты: они имеют одинаковые свойства: имя, счет в банке и т.п. Значит, в системе должен появиться класс с именем Покупатель, который будет шаблоном объектов Иванов и Петров.

Некоторые возможные классы будут выявлены при рассмотрении трех стереотипов: сущность (entity), граница (boundary) и управление (control). **Стереотип** – это механизм, позволяющий категоризировать классы. Он используется для создания нового типа элемента, в данном случае нового типа класса.

Например, Вы хотите выделить все экранные формы в модели. Для этого нужно создать стереотип Form (Форма).

**Стереотипы** помогают лучше понять ответственности каждого класса в модели, категоризировать выполняемые ими функции. В UML для этого применяют три основных стандартных вида стереотипов классов: классы сущности, граничные классы и управляющие классы.

**Класс-сущность** содержит информацию, хранимую постоянно. Используется для моделирования данных и поведения с длинным жизненным циклом. Они могут представлять информацию о предметной области, а могут представлять элементы самой системы. Часто являясь абстракциями предметной области, они имеют наибольшее значение для пользователя, поэтому в их названиях применяются термины предметной области. Если существует проект базы данных, то можно обратиться к изучению названий таблиц, многие из них станут классами-сущностями. Обозначаются классы сущности стереотипом <> либо специальной пиктограммой
![[Pasted image 20250309221809.png]]

**Граничными классами** называются классы, расположенные на границе системы со всем остальным миром, и т.е. они обеспечивают взаимодействие между окружающей средой и внутренними элементами системы.

Для вычисления пограничных классов необходимо исследовать диаграммы вариантов использования. Для каждого взаимодействия между актером и прецедентом нужно создать хотя бы один граничный класс. Обратите внимание, что если два действующих лица инициируют один прецедент, то они могут применять один общий пограничный класс для взаимодействия с системой. Обозначаются граничные классы именем стереотипа <> либо специальной пиктограммой
![[Pasted image 20250309222017.png]]

Управляющий класс отвечает за координацию действий других классов. Они служат для моделирования последовательного поведения одного или нескольких прецедентов и координации событий, реализующих заложенное в них поведение. Обозначаются управляющие классы именем стереотипа <> либо специальной пиктограммой
![[Pasted image 20250309222124.png]]
Управляющие классы можно представить, как «исполняющие» прецедент, поэтому у каждого варианта использования обычно имеется один управляющий класс, контролирующий последовательность событий этого прецедента. Они обычно зависят от приложения.

Управляющий класс делегирует ответственности другим классам. Сам он может получать мало сообщений, но отсылать множество. Его называют классом-менеджером. Он запускает альтернативные потоки и знает, как поступить в случае ошибки. На начальном этапе проектирования управляющие классы создаются для каждой пары актер/прецедент, в дальнейшем они могут объединяться, разделяться или исключаться.

### Документирование классов
После того, как класс создан, информацию о нем необходимо документировать. Заметим, что документация предназначена для описания предназначения класса, а не его структуры.

Пример. Если в нашей модели присутствует класс Сотрудник, то хорошим описанием для него будет:
**Сотрудник** – это человек, работающий на фирме. Класс содержит информацию, необходимую для исполнения организацией своих обязанностей по отношению к сотруднику (начисление зарплаты, перевод на другую должность, увольнение и т.п.)
Плохим описанием будет описание структуры класса, которая может быть и так описана с помощью атрибутов. Например, плохое описание класса *Сотрудник*:
- Имя, 
- телефон, 
- адрес, 
- должность, 
- зарплата.

В StarUML документирование классов выполняется также как и описанное выше документирование прецедентов. Нужно выделить класс, который вы хотите описать, открыть окно документирования Documentation на инспекторе модели и ввести описание класса.

### Когда применяются диаграммы классов
Диаграммы классов составляют фундамент UML, и поэтому их постоянное применение является условием достижения успеха. Трудность, связанная с диаграммами классов, заключается в том, что они настолько обширны, что их применение может оказаться непомерно сложным. Приведем несколько полезных советов.

- Не пытайтесь задействовать сразу все доступные понятия. Начните с самых простых, описанных в этой главе: классов, ассоциаций, атрибутов, обобщений и ограничений. Обращайтесь к дополнительным понятиям, рассмотренным в главе 5, только если они действительно необходимы.
- Я пришел к выводу, что концептуальные диаграммы классов очень полезны при изучении делового языка. Чтобы при этом все получалось, необходимо всячески избегать обсуждения программного обеспечения и применять очень простые обозначения.
- Не надо строить модели для всего на свете, вместо этого следует сконцентрироваться на ключевых аспектах. Лучше создать мало диаграмм, которые постоянно применяются в работе и отражают все внесенные изменения, чем иметь дело с большим количеством забытых и устаревших моделей.

Самая большая опасность, связанная с диаграммами классов, заключается в том, что вы можете сосредоточиться исключительно на структуре и забыть о поведении. Поэтому, рисуя диаграммы классов для того, чтобы разобраться в программном обеспечении, используйте какие-либо формы анализа поведения. Если вы применяете эти методы поочередно, значит, вы двигаетесь в верном направлении.