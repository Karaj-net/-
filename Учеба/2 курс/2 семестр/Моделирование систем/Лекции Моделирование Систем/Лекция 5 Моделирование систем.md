#Моделирование_систем
10.03.2025
# Диаграмма последовательности
Диаграмма последовательности используется для визуализации взаимодействия между объектами в системе. Она показывает порядок сообщений, которыми объекты обмениваются друг с другом во времени и их жизненный цикл. Это самый простой и удобный инструмент для демонстрации всех интеграций и взаимодействий в рамках проектируемого бизнес-процесса.

Основные элементы, из которых состоит sequence-диаграмма: объекты (зеленое), линии жизни (красное), сообщения (синее).
![[Pasted image 20250310142924.png]]

Диаграммы взаимодействия (interaction diagrams) описывают взаимодействие групп объектов в различных условиях их поведения. UML определяет диаграммы взаимодействия нескольких типов, из которых наиболее употребительными являются диаграммы последовательности. Обычно диаграмма последовательности описывает один сценарий. На диаграмме показаны экземпляры объектов и сообщения, которыми обмениваются объекты в рамках одного прецедента (use case).

**Объекты** — это сущности, которые взаимодействуют друг с другом. Например, пользователь, топик или очередь, микросервис. Помимо названия, объекты могут еще отличаться своим типом:
![[Pasted image 20250310142955.png]]
**Линии жизни** (lifelines) отображают течение времени, а также активность или исполнение определенных функций объекта. Представляют из себя вертикальную линию с блоком активности.

**Диаграммы последовательностей используются для уточнения диаграмм прецедентов**, более детального описания логики сценариев использования. Это отличное средство документирования проекта с точки зрения сценариев использования!

Действующие лица, присутствующие на диаграммах взаимодействия, выделяются из потока событий как сущности, запускающие процессы. На одной диаграмме их может быть несколько.

Для того чтобы поместить экземпляр уже созданного ранее на диаграмме прецедентов действующего лица на диаграмму взаимодействия, просто перетащите его с навигатора модели на рабочее поле диаграммы.

Каждый объект или действующее лицо на диаграмме последовательностей имеет свою линию жизни, которая обозначается пунктиром.

**_Фокус управления (активность, focus of control)_** - специальный символ на диаграмме последовательности, указывающий период времени, в течение которого объект выполняет некоторое действие, находясь в активном состоянии.

Фокус управления изображается тонким прямоугольником, расположенным на линии жизни (рис. 3).
![[Pasted image 20250310143202.png]]

Иногда отображение фокуса активности и нумерации сообщений на диаграмме могут сделать ее трудной для чтения. Чтобы фокус управления и нумерация сообщений не отображались на диаграмме последовательности в StarUML нужно открыть редактор свойств этой диаграммы в инспекторе модели и в разделах ShowSequenceNumber и ShowActivation убрать «галочки»
![[Pasted image 20250310143321.png]]
**Рис. 5 Управление отображением фокуса управления и нумерации сообщений**

Объекты и действующие лица на диаграммах последовательности обмениваются сообщениями. Сообщения обозначаются стрелками, идущими от отправителя к получателю.

**_Сообщение_** (**_message_**) — спецификация передачи информации от одного элемента модели к другому с ожиданием выполнения определенных действий со стороны принимающего элемента (рис. 6).
![[Pasted image 20250310143356.png]]
**Рис. 6 Сообщение**

Для сообщений на диаграммах последовательностей, как и для других элементов модели, доступен ряд спецификаций.

Во-первых, у каждого сообщения должно быть имя, соответствующее его цели.

Во-вторых, сообщения на диаграммах последовательностей можно соотнести с операциями, определенными для классов. Если от одного объекта к другому направлено сообщение, то это означает, что объект-источник вызывает операцию объекта-приемника. Объект не может вызвать произвольную операцию: она должна быть доступна этому объекту.

В особых случаях сообщение не становится операцией: например, ввод логина и пароля подразумевает их печать в соответствующих полях, и сообщение будет реализовано в виде поля ввода в окне программы.

Процедура создания операций из сообщений будет описана ниже.

В-третьих, мы можем для каждого сообщения установить тип синхронизации. Каждому типу соответствует его обозначение.

**_Вызов операции (процедуры) (call)_** вызывает операцию того объекта, к которому направлено. Объект может вызвать свою операцию. Тогда стрелка начинается и заканчивается на линии жизни одного и того же объекта, такое сообщение называется **_рефлексивным_**.

Синхронное сообщение обозначается стрелкой с закрашенным наконечником (рис. 7).
![[Pasted image 20250310143501.png]]
**_Асинхронное сообщение (send)_** посылает объекту сигнал. При этом источник не ждет отклика приемника или подтверждения получения, а продолжает свою работу. Обозначается нежирной стрелкой (рис. 8).
![[Pasted image 20250310143520.png]]

**_Ответное сообщение (return)_** возвращает значение из процедуры тому объекту, к которому направлено. Обозначается пунктирной стрелкой (рис. 61)

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

**_Создать объект (create)_** – создает новый объект. Обозначается стрелкой со стереотипом create (рис. 9).

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

**Создание объекта**

**Уничтожить объект (destroy)** удаляет объект. Объект может уничтожить сам себя. Обозначается стрелкой со стереотипом "destroy". При уничтожении объекта на его линии жизни появляется символ разрушения, который обозначается крестом (рис. 10).

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

**Уничтожение объекта**

Для определения типа сообщения в StarUML нужно выполнить след действия: выделите сообщение, щелкнув по соответствующей стрелке один раз левой кнопкой мыши, откройте редактор свойств, выберите на нем раздел ActionKind и в выпадающем списке выберите тот тип синхронизации, который вы хотите установить (рис. 11).

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

Рис. 11 **Выбор типа сообщения**

**Синхронные и асинхронные вызовы**

Если вы были очень внимательны, то заметили, что стрелки в последних двух диаграммах отличаются от предыдущих. Это небольшое отличие достаточно важно в UML версии 2. Здесь закрашенные стрелки показывают синхронное сообщение, а простые стрелки обозначают асинхронное сообщение.

Если вызывающий объект посылает **синхронное сообщение** (synchronous message), то он должен ждать, пока обработка сообщения не будет закончена, например при вызове подпрограммы. Если вызывающий объект посылает **асинхронное сообщение** (asynchronous message), то он может продолжать работу и не должен ждать ответа. Асинхронные вызовы можно встретить в многопоточных приложениях и в промежуточном программном обеспечении, ориентированном на сообщения.

Асинхронность улучшает способность к реагированию и уменьшает количество временных соединений, но сложнее в отладке. Разница в изображении стрелок едва уловима; действительно их довольно трудно отличить. Кроме того, это изменение, введенное в UML 1.4, не обладает обратной совместимостью, поскольку до этого асинхронные сообщения обозначались половинными стрелками, как показано на рис. 4.5.

Для создания новой диаграммы последовательности нужно выполнить следующие шаги: щелкнуть правой кнопкой мыши по папке представления Logical View в навигаторе модели, в контекстном меню выбрать пункт Add Diagram, в списке выбрать диаграмму последовательности Sequence Diagram (рис. 12).

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

**Рис .12Добавление диаграммы последовательности**

Мы также можем использовать диаграмму последовательности для детализации прецедента. Для этого нужно связать диаграмму с прецедентом: для создания диаграммы щелкните правой кнопкой мыши по прецеденту, а не по папке Logical View. Однако, если мы строим диаграмму последовательности для анализа системы, то лучше все-таки помещать ее в Logical View.

Составим диаграмму последовательности для случая, когда покупатель успешно оформляет заказ (рис. 13).

Покупатель выбирает опцию «Оформить заказ» (place order), при этом вызывается некоторый объект PlaceOrder (забегая вперед скажем, что это будет граничный объект, принадлежащий соответствующему граничному классу). Далее открывается форма ввода личных данных покупателя и его кредитной карты (EnterPersonalInformation), на ней покупатель вводит свое имя, адрес, телефон, адрес электронной почты (enter personal information) и кредитные данные. Информация принимается и открывается форма подтверждения заказа (ConfirmOrder), покупатель подтверждает, что согласен с реквизитами заказа (confirm order), детали заказа сохраняются для дальнейшего использования (save the details). Фокус управления передается некоторому управляющему объекту (PlaceOrderManager), который обращается к внешней кредитной системе (Credit System) для проведения платежа. Если платеж прошел успешно (а именно такой сценарий мы сейчас и рассматриваем), то PlaceOrderManager посылает сообщение (create order) создать объект Заказ (Order), затем вызывает форму подтверждения заказа (OrderConfirmation). Объект Заказ (Order) обращается к объектам Товар (Item) для того, чтобы получить информацию о товарах и создает заказ. Процесс завершается.

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image012.gif)

Рис. 13 **Диаграмма последовательности сценария Оформление заказа**

**Замечание.** Обратите внимание, что символ объекта Товар (Item) на диаграмме последовательности отличается от символов других объектов. Дело в том, что мы задали множественный экземпляр класса. Действительно, заказ может состоять из нескольких товаров, значит объекту Заказ (Order) требуется получить информацию о нескольких объектах Товар (Item). Вместо того, чтобы представлять каждый товар отдельно мы используем нотацию UML для множественного экземпляра класса, представляя одним значком несколько объектов.

Чтобы сделать объект множественным в StarUML выделите объект, щелкнув по нему мышью один раз, в открывшемся редакторе свойств поставьте флажок в разделе IsMultiInstance (рис. 14).

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image014.gif)

рис. 14 **Создание множественного объекта**

**Ветвление потока управления**

Обычно для основного потока событий большинства прецедентов строится одна диаграмма последовательности, для альтернативных потоков - дополнительные диаграммы, описывающие все остальные сценарии. Так поступают потому, что на диаграмме последовательности действий сложно отобразить логику ЕСЛИ-ТО-ИНАЧЕ. Однако если это необходимо и не загромождает диаграмму, то это можно сделать с помощью условий. Приведем пример.

В процессе оформления покупателем заказа возможны несколько альтернатив. Например, на втором шаге оформления заказа покупатель может подтвердить свой заказ, а может и не согласиться с его реквизитами (см. пример выше). На диаграмме последовательности это можно изобразить так, как это показано на рисунке 15.

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image016.gif)

**Рис. 15 Ветвление потока управления**

Если покупатель подтверждает свой заказ на втором шаге (customer confirmed the order), то процесс переходит оплате заказа. Если покупатель не подтверждает заказ (customer did not confirm the order), то открывается корзина покупателя. Условие, как это принято в нотации UML, записывается в квадратных скобках []. Обратите внимание, что мы упростили предыдущую диаграмму описания оформления заказа, иначе добавление ветвей процесса сделало бы ее громоздкой и трудно понимаемой. На практике лучше изображать диаграмму последовательности отдельно для каждого сценария потока событий.

**Циклы, условия и тому подобное**

Общая проблема диаграмм последовательности заключается в том, как отображать циклы и условные конструкции. Прежде всего надо усвоить, что диаграммы последовательности для этого не предназначены. Подобные управляющие структуры лучше показывать с помощью диаграммы деятельности или собственно кода. Диаграммы последовательности применяются для визуализации процесса взаимодействия объектов, а не как средство моделирования алгоритма управления.

Как было сказано, существуют дополнительные обозначения. И для циклов, и для условий используются **фреймы взаимодействий** (interaction frames), представляющие собой средство разметки диаграммы взаимодействия.

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)

Рис. 16

В основном фреймы состоят из некоторой области диаграммы последовательности, разделенной на несколько фрагментов. Каждый фрейм имеет оператор, а каждый фрагмент может иметь защиту. (В табл. 4.1 перечислены общепринятые операторы для фреймов взаимодействия.) Для отображения цикла применяется оператор **loop** с единственным фрагментом, а тело итерации помещается в защиту. Для условной логики можно использовать оператор **alt** и помещать условие в каждый фрагмент. Будет выполнен только тот фрагмент, защита которого имеет истинное значение. Для единственной области существует оператор **opt**.

![](file:///C:/Users/73B5~1/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg)

_Общепринятые операторы для фреймов взаимодействия_

Фреймы взаимодействия – новинка UML 2. В диаграммах, разработанных до создания UML 2, применяется другой подход; кроме того, некоторые разработчики не любят фреймы и предпочитают прежние соглашения. На рис. 4.5 показаны некоторые из этих неофициальных приемов.

**_Взаимосвязь диаграмм классов и последовательности_**

Процесс построения модели системы является итеративным. Особенно хорошо это можно видеть при создании диаграмм классов и последовательности. Какую диаграмму создавать первой: классов или последовательности? Одни разработчики начинают с диаграмм классов, другие – наоборот, с последовательности. И в том и в другом случае, скорее всего, обе эти диаграммы, построенные для одного сценария, будут в дальнейшем подвергаться изменению. После построения диаграмм последовательности на диаграммах классов могут появиться новые классы, а на диаграммах последовательности – новые объекты, которых раньше там не было, но они придут туда из диаграмм классов. Возможно, что некоторые объекты и классы будут, напротив, удалены.

**Когда применяются диаграммы последовательности**

Диаграммы последовательности следует применять тогда, когда требуется посмотреть на поведение нескольких объектов в рамках одного прецедента. Диаграммы последовательности хороши для представления взаимодействия объектов, но не очень подходят для точного определения поведения.

Если вы хотите посмотреть на поведение одного объекта в нескольких прецедентах, то примените диаграмму состояния. Если же надо изучить поведение нескольких объектов в нескольких прецедентах или потоках, не забудьте о диаграмме деятельности.

Если требуется быстро исследовать несколько вариантов взаимодействия, лучше использовать CRC_карточки, поскольку это позволяет избежать непрерывного рисования и стирания. Часто бывает удобно поработать с CRC_карточками для просмотра вариантов взаимодействия, а затем с помощью диаграмм взаимодействий фиксировать те взаимодействия, которые будут применяться позже.

Другим полезным видом диаграмм взаимодействий являются коммуникационные диаграммы, которые показывают соединения, и временные диаграммы, показывающие временные интервалы.