#Моделирование_систем 
17.03.2025
# Диаграмма деятельности
**Диаграммы деятельности** – это технология, позволяющая описывать логику процедур, бизнес-процессы и потоки работ. Во многих случаях они напоминают блок-схемы, но принципиальная разница между диаграммами деятельности и нотацией блок-схем заключается в том, что первые поддерживают параллельное процессы.

Диаграммы деятельности подвергались самым большим изменениям при смене версий языка UML, поэтому неудивительно, что они были снова изменены и существенно расширены в UML 2. В UML 1 диаграммы деятельности рассматривались как особый случай диаграмм состояний. Это вызвало немало трудностей у специалистов, моделирующих потоки работ, для которых хорошо подходят диаграммы деятельности. В UML 2 это ограничение было ликвидировано.

На рис. 1 показан пример простой диаграммы деятельности. Мы стартуем с начального узла (initial node), а затем выполняем операцию **Receive Order** (Принять заказ). Затем идет ветвление (fork), которое имеет один входной поток и несколько выходных параллельных потоков.

Из рис. 1 видно, что операции **Fill Order** (Заполнить заявку), **Send Invoice** (Послать счет) и следующие за ними выполняются параллельно. По существу, в данном случае это означает, что последовательность операций не имеет значения. Я могу заполнить заявку, послать счет, доставить товар (**Delivery**), а затем получить оплату (**Receive Payment**); или я могу послать счет, получить оплату, заполнить заявку, а затем доставить товар.

Я могу также выполнять операции поочередно. Я беру со склада первую позицию заказа, печатаю счет, беру вторую позицию заказа, кладу счет в конверт и т. д. Или я могу что-то делать одновременно: печатать счет одной рукой, а другой рукой брать что-нибудь со склада. Согласно диаграмме, любая из этих последовательностей действий допустима.

Диаграмма деятельности позволяет любому, кто выполняет данный процесс, выбирать порядок действий. Другими словами, диаграмма только устанавливает правила обязательной последовательности действий, которым я должен следовать. Это важно для моделирования бизнес-процессов, поскольку эти процессы часто выполняются параллельно. Такие диаграммы также полезны при разработке параллельных алгоритмов, в которых независимые потоки могут выполнять работу параллельно.

![[Pasted image 20250317133624.png]]

При наличии параллелизма необходима синхронизация. Мы не закрываем заказ, пока он не оплачен и не доставлен. Это показывается с помощью **объединения** (join) перед операцией **Close Order** (Закрыть заказ). Исходящий из объединения поток выполняется только в том случае, когда все входящие потоки достигли объединения. Поэтому вы можете закрыть заказ, только когда принята оплата и заказ доставлен.

В UML 1 действовали определенные правила для балансировки ветвлений и объединений, так как диаграммы деятельности представляли особый случай диаграмм состояний. В UML 2 в такой балансировке уже нет необходимости. 

Заметьте, что узлы на диаграмме деятельности называются операциями (actions), а не активностями (activities). Строго говоря, деятельность относится к последовательности действий, поэтому диаграмма представляет деятельность, состоящую из операций. 

Условное поведение схематически обозначается с помощью решений (decisions) и слияний (merges). **Решение**, которое в UML 1 называлось ветвью, имеет один входящий поток и несколько защищенных выходных потоков. Каждый выходной поток имеет защиту – условное выражение, помещенное в квадратные скобки. Каждый раз при достижении решения выбирается только один из выходных потоков, поэтому защиты должны быть взаимно исключающими. Применение **[else]** в качестве защиты означает, что поток **[else]** используется в том случае, когда другие защиты данного решения принимают ложное значение. 

На рис. 1 решение располагается после операции заполнения заявки. Если у вас срочный заказ, то он выполняется в течение суток (**Overnight Delivery**); в противном случае производится обычная доставка (**Regular Delivery**). Слияние (merge) имеет несколько входных потоков и один выходной. 

**Слияние** (merge) имеет несколько входных потоков и один выходной.**Слияние** обозначает завершение условного поведения, которое было начато решением.

Операции могут быть реализованы или как вложенные деятельности или как методы классов. Вложенную деятельность можно обозначить с помощью символа «граблей». Вызов метода отображается с помощью синтаксиса **имя_класса: имя_метода**. Можно также вставить в символ операции фрагмент кода, если поведение представлено не единственным вызовом метода. Например, рисунок 2 или 3
![[Pasted image 20250317134514.png]]
![[Pasted image 20250317134530.png]]

Диаграммы деятельности рассказывают о том, что происходит, но ничего не говорят о том, кто какие действия выполняет. В программировании это означает, что диаграмма не отражает, какой класс является ответственным за ту или иную операцию. Для распределение обязанностей между подразделениями фирмы. Это не всегда представляет собой трудность; часто имеет смысл сконцентрироваться на том, что происходит, а не на том, кто какую роль играет в данном сценарии.

Можно разбить диаграмму деятельности на разделы (partitions), чтобы показать, кто что делает, то есть какие операции выполняет тот или иной класс или подразделение предприятия. На рис. 4 приведен простой пример, показывающий, как операции по обработке заказа могут быть распределены между различными подразделениями.
![[Pasted image 20250317134553.png]]

Этот способ называют **плавательными** **дорожками**(swim lanes)

Сигналы. В простом примере на рис. 1 диаграммы деятельности имеют четко определенную стартовую точку, соответствующую вызову программы или процедуры. Кроме того, операции могут отвечать на сигналы.

Временной сигнал (time signal) приходит по прошествии времени. Такие сигналы могут означать конец месяца в отчетном периоде или приходить каждую секунду в контроллере реального времени.
Например, рисунок 5 
![[Pasted image 20250317135319.png]]

В случае, показанном на рис. 5, до моего отлета остается два часа (Two hours before flight), и мне пора собирать багаж. Если я упакую его раньше времени, то все равно не смогу уехать, пока не прибудет такси. 
Если такси приходит (Taxi Arrives) до того, как я успею собрать багаж (Pack Bags), то оно должно ждать меня, пока я не закончу.

Все равно придется ждать, чтобы уехать из аэропорта

Мы можем как принимать сигналы, так и посылать их. 

В UML 2 параллельно употребляются термины **поток** (flow) и **ребро** (edge) для обозначения связи между двумя операциями. Самый простой вид ребра – это обычная стрелка между двумя операциями

При возникновении трудностей с разводкой линий можно воспользоваться разъемами (connectors), которые позволят вам не рисовать линии на всем их протяжении.

Однако по ребрам можно передавать объекты. Передачу объекта вдоль ребра можно показать, помещая на ребро прямоугольник класса

![[Pasted image 20250317140015.png]]
Показывать контакты на диаграмме деятельности не обязательно. Но с помощью контактов можно. Контакты удобны, когда требуется увидеть данные, принимаемые и передаваемые различными процедурами. При моделировании бизнес процессов посредством контактов можно отображать ресурсы, которые потребляются и производятся различными процедурами. С помощью контактов можно без опаски показать несколько потоков, входящих в одну и ту же операцию.

При работе с диаграммами деятельности часто сталкиваешься с ситуациями, когда выход одной операции инициирует многочисленные вызовы другой операции. Есть несколько способов показать это, но лучше всего подходит область расширения. Область расширения (expansion region) отмечает область диаграммы деятельности, где операции выполняются один раз для каждого элемента коллекции.
![[Pasted image 20250317140650.png]]

Самое большое достоинство диаграмм деятельности заключается в том, что они поддерживают и стимулируют применение параллельных процессов. Именно благодаря этому они представляют собой мощное средство моделирования потоков работ. Множество импульсов к развитию UML 2 пришло от людей, вовлеченных в эти потоки работ.

Можно также применять диаграмму деятельности в качестве совместимой с языком UML блок_схемы. Хотя это позволяет разрабатывать блок_схемы, близкие к UML, но вряд ли это очень захватывающий процесс. В принципе, можно воспользоваться преимуществами, предоставляемыми ветвлением и объединением, для описания параллельных алгоритмов одновременно выполняющихся программ. Хотя сам я не очень активно применял параллельные циклы, но у меня также нет достаточного количества подтверждений этого от людей, имеющих большой опыт их применения. Я думаю, причина в том, что сложность параллельного программирования состоит в противостоянии данных параллельных процессов, а диаграммы деятельности не могут оказать большой помощи в этом вопросе. В наибольшей степени их мощь может проявиться в случае применения UML как языка программирования. Здесь диаграммы деятельности являются ценным инструментом для представления логики поведения систем. Мне часто приходилось видеть, как диаграммы деятельности применялись для описания прецедентов. Опасность такого подхода в том, что часто эксперты в предметной области с трудом могут им следовать. Если дело обстоит так, то лучше обойтись обычной текстовой формой.
