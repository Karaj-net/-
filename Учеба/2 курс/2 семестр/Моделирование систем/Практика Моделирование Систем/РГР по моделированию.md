#Моделирование_систем
# Составить модель для информационной системы управления конфликтами и претензиями в строительстве
## Список диаграмм
1. Диаграмма прецедентов
2. Диаграмма классов 
3. Диаграмма объектов
4. Диаграмма последовательности
5. Диаграмма деятельности
6. Диаграмма состояний
7. Диаграмма коопераций
8. Диаграмма компонентов
9. Диаграмма развертывания
## Конфликты 
- **Нарушение сроков строительства**. Подрядчик не выполняет обязательства вовремя. Типичные причины: срыв графика, задержка поставок, некачественное планирование, форс-мажор.
- **Низкое качество работ**. Исполнитель сдал работы несоответствующего качества, при этом отказывается признать это.
- **Завышенная цена**. Недобросовестные исполнители искусственно завышают стоимость дополнительных работ, которые возникают в процессе проектирования или строительства.
- **Непредвиденные затраты**. Дополнительные затраты могут возникать как в процессе проектирования, так и на стадии строительства. 
- **Ошибки**. Ошибки в сложных строительных проектах могут приводить к конфликтам из-за обманутых ожиданий, попыткам найти виновных или переложить вину.
- **Нарушение прав на общие объекты недвижимости**. Конфликты могут возникать по поводу доступа к парковкам, подвалам, лифтам и другим общим объектам.

## Претензии
- **О нарушении требований к качеству объекта**. В претензии описываются допущенные нарушения и указываются требования в связи с ними.
- **О выплате неустойки за нарушение срока передачи объекта**. В претензии приводится расчёт неустойки за просрочку передачи, требование и указываются банковские реквизиты для перечисления.
- **О возврате цены ДДУ в связи с уменьшением площади**. Застройщик отказывается вернуть деньги в связи с уменьшением площади или имеются разногласия относительно общей площади помещения.
- **О возмещении ущерба после залива по вине застройщика**. Это может произойти, например, в связи с нарушениями строительных норм застройщиком (нарушения при проведении кровельных, фундаментных работ, отсутствие гидроизоляции и т. д.).

## Кто участвует в конфликте и претензиях в сфере строительства 
- Подрядчик
- Исполнитель
- Заказчик 
- Юр лицо
- Помощник
- Застройщик

## Управления конфликтами и претензиями в строительстве
**Управление конфликтами и претензиями в строительстве** включает в себя выявление, документирование и разрешение споров, возникающих в ходе строительных проектов. Цель такого управления — минимизировать финансовые последствия претензий и защитить интересы инвестора.

**Некоторые методы управления конфликтами в строительстве:**
- **Профилактика через детальное планирование**. Важно чётко прописать технические требования, сроки и финансовые условия в договоре. Это минимизирует недопонимание.
- **Документирование**. Фотофиксация этапов, письменные согласования в почте и мессенджерах, акты выполненных работ — обязательные элементы работы. Это защищает от субъективных трактовок на поздних стадиях проекта. 
- **Принцип постоянной коммуникации**. Руководитель проекта должен быть всегда на связи, доступен для обсуждения проблем, даже если решение проблемы не сиюминутное и требует времени.
- **Эмоциональный нейтралитет в переговорах**. Эскалация конфликта часто возникает из-за реакции на эмоции оппонента. Сохранение хладнокровия позволяет перевести диалог в конструктивное русло.
- **Тактика отсроченного решения**. В острых ситуациях эффективен метод «тайм-аута». Предложено сторонам оформить все свои претензии письменно и вернуться к обсуждению после анализа.
- **Работа с групповыми конфликтами**. При массовых недовольствах важно выявить ключевых участников. Переговоры один на один с лидерами мнений не только снижают градус напряжённости, но и эффективнее в разы.

**Некоторые методы управления претензиями в строительстве:**
- **Чёткое понимание контрактных документов**. В договоре должны быть прописаны права и обязанности каждой стороны в случае возникновения спора. Также следует установить процедуры подачи и разрешения претензий. 
- **Отслеживание основных этапов проекта**. Это поможет выявить потенциальные проблемы на раннем этапе и принять меры, чтобы они не превратились в полноценные претензии.
- **Тщательное документирование претензий**. Если возможно, следует добавить фото или видео. Важно также получить подтверждающую документацию от третьих сторон (например, поставщиков материалов или субподрядных компаний)

## Как должна работать система 
Заказчик, если у него есть претензии или конфликты с исполнителем, то он может  зарегистрироваться на сайте и составить заявление с описанием проблемы, позже сотрудник может осмотреть данное заявление и удалить его или может принять его и потом дать совет по разрешению данной проблемы, конечно же после оплаты
Вот список возможных решений:
Для конфликтов между заказчиком и строителями рекомендуется:
- **Заранее зафиксировать все нюансы в договоре**. Это поможет избежать конфликтов из-за размытости границ ответственности.  
- **Проверить материалы, привезённые клиентом**. Так можно не допустить появления на стройке некачественных или неподходящих расходников.  
- **Не пытаться переложить вину с себя на кого-то другого**. Главная задача — найти выход, который удовлетворит клиента.  
- **Предложить решение, которое устроит заказчика**. Можно открыто проговорить проблему и предложить конкретный план со сроками. Возможно, стоит предложить финансовые уступки.  

Для споров с застройщиками возможны следующие варианты решения:
- **Досудебное урегулирование**. Можно направить застройщику претензию с требованиями устранить нарушения.  
- **Судебный порядок**. Можно обратиться в суд для защиты своих прав (взыскание неустойки, расторжение договора, компенсация убытков).  
- **Обращение в государственные органы**. Можно подать жалобу в контролирующие органы, такие как Роспотребнадзор или Госстройнадзор.  
Чтобы разобраться со всеми нюансами строительных споров, рекомендуется обратиться за помощью к юристу.
После этого заказчик может
# Краткое описание всех диаграмм
## Диаграмма прецедентов
### Краткое описание диаграммы вариантов использования

### 1. Контекст и назначение  
Диаграмма вариантов использования (Use Case Diagram) визуализирует взаимодействие между **актерами** (ролями пользователей или внешних систем) и **вариантами использования** (функциональными возможностями системы). Она помогает определить требования к системе и границы ее функциональности.

### 2. Основные элементы
- **Актеры (Actors)** – внешние сущности, взаимодействующие с системой (например, _Пользователь_, _Администратор_, _Платежный шлюз_).
- **Варианты использования (Use Cases)** – функции системы (например, _«Оформить заказ»_, _«Авторизоваться»_, _«Сгенерировать отчет»_).
- **Связи (Relationships)** – взаимодействия между актерами и use case'ами:
    - **Ассоциации** (линии между актером и use case) – кто и как использует функцию.
    - **Включение (Include)** – обязательная связь между use case'ами (например, _«Оплатить заказ»_ включает _«Проверить баланс»_).
    - **Расширение (Extend)** – условное выполнение (например, _«Восстановить пароль»_ расширяет _«Авторизоваться»_ при ошибке входа).
    - **Обобщение (Generalization)** – наследование ролей или use case'ов (например, _«Администратор»_ – частный случай _«Пользователя»_).

### 3. Дополнительные детали
- **Системные границы** – прямоугольник, отделяющий систему от внешних актеров.
- **Комментарии и ограничения** – пояснения к сложным связям или условиям.
**Пример:**  
Для системы _«Онлайн-магазин»_ актеры: _Клиент_, _Админ_, _Курьер_. Use case'ы: _«Добавить товар в корзину»_, _«Оформить доставку»_, _«Управление заказами»_. Связь: _«Оплата»_ включает _«Проверку карты»_.
Диаграмма дает общее понимание функционала системы и взаимодействий без углубления в технические детали.

## Диаграмма классов: суть, элементы и их влияние на код
### 1. Суть диаграммы классов
Диаграмма классов (Class Diagram) — это структурная UML-диаграмма, которая отображает **классы**, их **атрибуты**, **методы** и **взаимосвязи** в системе. Она служит основой для проектирования объектно-ориентированного кода, помогая визуализировать архитектуру программы до ее реализации.

---
### 2. Основные элементы диаграммы классов
#### ① Класс (Class)
**Описание:** Моделирует объект предметной области (например, пользователь, заказ, товар).  
**Состав:**
- **Имя класса** (например, `User`, `Order`).
- **Атрибуты** (поля, свойства) – `-name: String`, `-balance: double`.
- **Методы** (функции) – `+login()`, `+updateProfile()`.
**Пример:**
```
┌─────────────────┐  
│      User       │  
├─────────────────┤  
│ -id: int        │  
│ -name: String   │  
│ -email: String  │  
├─────────────────┤  
│ +login()        │  
│ +updateProfile()│  
└─────────────────┘  
```

---
#### ② Атрибуты и методы
- **Атрибуты** – переменные класса (например, `-price: double`).
    - Модификаторы доступа:
        - `-` private (только внутри класса),
        - `+` public (доступ извне),
        - `#` protected (доступ в наследниках).
- **Методы** – функции класса (например, `+calculateTotal(): double`).
---
#### ③ Ассоциации (связи между классами)
Показывают, как классы взаимодействуют друг с другом.
##### 1. Простая ассоциация
- Линия между классами, может быть подписана (**роль** и **кратность**).
- **Пример:**
    - `Customer` —(`1..*`)— `Order` ("один клиент может создать несколько заказов").
##### 2. Агрегация (Aggregation)
- Связь "часть-целое", где часть может существовать без целого (ромб на стороне целого).
- **Пример:**
    - `University` ◇— `Student` (университет содержит студентов, но студент может существовать без университета).

##### 3. Композиция (Composition)
- Более строгая связь "часть-целое": часть не существует без целого (закрашенный ромб).
- **Пример:**
    - `Order` ◆— `OrderItem` (позиция заказа не существует без самого заказа).
##### 4. Наследование (Generalization)
- Класс-потомок наследует свойства и методы родителя (стрелка с треугольным концом).
- **Пример:**
    
    - `Admin` → `User` (админ — это пользователь с дополнительными правами).
        
##### 5. Зависимость (Dependency)
- Пунктирная стрелка: один класс временно использует другой (например, передача параметра в метод).
- **Пример:**
    - `Order` ⤳ `PaymentService` (заказ зависит от сервиса оплаты для обработки платежа).
---
### 3. Пример диаграммы классов (интернет-магазин)
```
┌─────────────┐       ┌─────────────┐        ┌─────────────┐  
│   Customer  │       │    Order    │        │  Product    │  
├─────────────┤       ├─────────────┤        ├─────────────┤  
│ -id: int    │       │ -id: int    │        │ -id: int    │  
│ -name: String│      │ -date: Date │        │ -name: String│  
└─────────────┘       └─────────────┘        └─────────────┘  
       ▲                      ◆                       ▲  
       |                      |                       |  
       | (1..*)        (1..*)|                (0..*) |  
       |______________________|                       |  
                   |                                  |  
                   ▼                                  |  
            ┌─────────────┐                           |  
            │ OrderItem   │                           |  
            ├─────────────┤                           |  
            │ -quantity: int│                         |  
            └─────────────┘                           |  
                   ◆                                  |  
                   |                                  |  
                   ▼                                  ▼  
            ┌─────────────┐                   ┌─────────────┐  
            │  Payment    │                   │  Category   │  
            ├─────────────┤                   ├─────────────┤  
            │ -amount: double│                │ -name: String│  
            └─────────────┘                   └─────────────┘  
```
**Объяснение:**
- `Customer` связан с `Order` (один ко многим).
- `Order` содержит `OrderItem` (композиция).
- `Product` может принадлежать к `Category` (агрегация).
- `Order` зависит от `Payment` (пунктирная стрелка).
---
### 4. Влияние на программный код
Диаграмма классов напрямую отображается в структуру кода:
- **Классы → Код (Java/C#/Python пример):**
```Java

    java
    
    Copy
    
    Download
    
    public class Customer {  
        private int id;  
        private String name;  
        private List<Order> orders; // связь 1..* с Order  
    }  
    
    public class Order {  
        private int id;  
        private List<OrderItem> items; // композиция  
    }  
    
- **Ассоциации → Поля или зависимости:**
    
    - Агрегация: поле-коллекция (`List<Student>` в `University`).
        
    - Наследование: `class Admin extends User`.
```
### Вывод
Диаграмма классов помогает:  
✅ Четко спроектировать архитектуру до написания кода.  
✅ Увидеть связи между сущностями и избежать ошибок.  
✅ Упростить рефакторинг и масштабирование системы.

Это "скелет" будущей программы, который можно сразу преобразовать в код на любом ООП-языке.

## Диаграмма «Сущность-Связь» (ERD): суть и ключевые элементы
### 1. Суть ERD
ERD (Entity-Relationship Diagram) — это модель данных, которая визуализирует **сущности** (таблицы), их **атрибуты** (поля) и **связи** между ними. Используется для проектирования реляционных баз данных (SQL) и документирования структуры данных.

---
### 2. Обязательные элементы ERD

#### ① Сущность (Entity)

**Что это:** Объект предметной области, который хранится в БД (аналог таблицы).  
**Примеры:**

- `Пользователь`, `Заказ`, `Товар`.  
    **Как изображается:**
```
┌─────────────────┐  
│    Сущность     │  
├─────────────────┤  
│  Атрибуты...    │  
└─────────────────┘  
```

---

#### ② Атрибуты (Attributes)

**Что это:** Поля сущности (столбцы таблицы).  
**Типы атрибутов:**
- **Простой** (неделимый, например, `id`).
- **Составной** (можно разбить, например, `адрес` → `улица, дом, квартира`).
- **Ключевые** (идентификаторы):
    - **Первичный ключ (PK)** — уникальный идентификатор (`user_id`).
    - **Внешний ключ (FK)** — ссылка на PK другой сущности (`order_id` в таблице `Платежи`).
- **Производный** (вычисляемый, например, `возраст` на основе `даты_рождения`).
**Пример:**
```
┌─────────────────┐  
│    Пользователь │  
├─────────────────┤  
│ *user_id (PK)   │  
│  name           │  
│  email          │  
│  #address       │  
└─────────────────┘  
```
(* — PK, # — составной атрибут).

---

#### ③ Связи (Relationships)

**Что это:** Отношения между сущностями (например, «Пользователь делает Заказ»).  
**Типы связей:**

1. **Один к одному (1:1)**
    
    - Пример: `Паспорт` — `Человек`.
        
    - Обозначение: `───|──────`.
        
2. **Один ко многим (1:N)**
    
    - Пример: `Автор` — `Книга` (один автор может написать много книг).
        
    - Обозначение: `───<──────`.
        
3. **Многие ко многим (M:N)**
    
    - Пример: `Студент` — `Курс` (студенты могут записываться на несколько курсов).
        
    - Обозначение: `───><────`.
        
    - **Реализация:** Через промежуточную таблицу (`Студент_Курс`).
        

**Обязательные указатели:**

- **Кратность** (например, `1..*` — «один или много»).
    
- **Роли** (подписи на связи: «создает», «принадлежит»).
    

**Пример связи 1:N:**
```
┌─────────────┐         ┌─────────────┐  
│  Автор      │         │   Книга     │  
└─────────────┘         └─────────────┘  
       │                     ▲  
       │ 1                  *│  
       └───── «пишет» ───────┘  
```

---

#### ④ Слабые и сильные сущности

- **Сильная сущность:** Существует независимо (имеет свой PK, например, `Пользователь`).
    
- **Слабая сущность:** Зависит от другой сущности (например, `Зависимый_член_семьи` без `Пользователя` не существует).  
    **Обозначение:** Двойной прямоугольник для слабой сущности.
    

---

### 3. Пример ERD (интернет-магазин)

```
┌─────────────┐        ┌─────────────┐        ┌─────────────┐  
│ Пользователь│        │    Заказ    │        │   Товар     │  
├─────────────┤        ├─────────────┤        ├─────────────┤  
│ *user_id (PK)│       │ *order_id (PK)│      │ *product_id (PK)│  
│  name       │        │  date       │       │  price      │  
└─────────────┘        └─────────────┘       └─────────────┘  
       │ 1                   * │                     ▲  
       └──── «создает» ────────┘                     │  
                                                     │  
                                          ┌──────────┴──────────┐  
                                          │     Заказ_Товар     │  
                                          ├─────────────────────┤  
                                          │ *order_id (FK)      │  
                                          │ *product_id (FK)    │  
                                          │  quantity           │  
                                          └─────────────────────┘  
```
**Пояснение:**

- Связь `M:N` между `Заказ` и `Товар` реализована через промежуточную таблицу `Заказ_Товар`.
    
- `Пользователь` и `Заказ` связаны отношением `1:N`.
    
---
### 4. Влияние на проектирование БД

ERD преобразуется в SQL-код:
```SQL

CREATE TABLE Пользователь (
    user_id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

CREATE TABLE Заказ (
    order_id INT PRIMARY KEY,
    user_id INT FOREIGN KEY REFERENCES Пользователь(user_id),
    date DATE
);

-- Для связи M:N
CREATE TABLE Заказ_Товар (
    order_id INT FOREIGN KEY REFERENCES Заказ(order_id),
    product_id INT FOREIGN KEY REFERENCES Товар(product_id),
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);
```

---
### 5. Вывод
**ERD нужна для:**  
✅ Четкого проектирования структуры БД до реализации.  
✅ Визуализации связей между таблицами.  
✅ Избежания избыточности данных (нормализация).

**Отличие от диаграммы классов:**
- ERD фокусируется на **данных** (таблицы, поля, связи).
- Диаграмма классов — на **поведении** (методы, инкапсуляция, полиморфизм).

ERD — это «карта» базы данных, которая помогает разработчикам и аналитикам говорить на одном языке.

## Диаграмма последовательности (Sequence Diagram): суть и элементы

### 1. Суть диаграммы последовательности
Диаграмма последовательности — это UML-диаграмма, которая показывает **взаимодействие между объектами/актёрами** в хронологическом порядке. Она визуализирует:

- **Кто** участвует в процессе (актёры, объекты).
- **Какие сообщения** передаются между ними.
- **В каком порядке** происходят вызовы методов или событий.


Используется для проектирования логики работы функций, API, сценариев пользовательского взаимодействия.

---

### 2. Обязательные элементы диаграммы последовательности

#### ① Участники (Actors/Objects)

- **Актеры** — внешние сущности (пользователь, внешняя система).
- **Объекты** — экземпляры классов, участвующие в процессе (например, `UserController`, `PaymentService`).  
    **Обозначение:** Прямоугольник с подписью, сверху — «линия жизни» (пунктирная вертикаль).
    
**Пример:**
```
[Пользователь]    [OrderService]    [PaymentGateway]
   |                   |                   |
```
---

#### ② Линия жизни (Lifeline)

**Что это:** Вертикальная пунктирная линия под участником, показывающая его активность в процессе.  
**Особенности:**
- Если объект уничтожается, линия обрывается крестом (`X`).
- Активация (прямоугольник на линии) — период, когда объект выполняет действие.

**Пример:**
```
[OrderService]  
   |  
   █ (активация при обработке заказа)  
   |  
```
---
#### ③ Сообщения (Messages)
Показывают взаимодействие между участниками. Типы сообщений:
##### 1. Синхронное сообщение (Solid Arrow →)
- Вызов метода с ожиданием ответа.
- **Пример:**
```
[Client] → [Server]: getData()  
```
##### 2. Асинхронное сообщение (Dashed Arrow ⤳)
- Вызов без ожидания ответа (например, событие).
- **Пример:**
```
[User] ⤳ [NotificationService]: sendEmail()  
```
##### 3. Возврат (Return Arrow ⤻)
- Ответ на синхронный запрос (не всегда рисуется явно).
- **Пример:**
```
[Server] ⤻ [Client]: data  
```
##### 4. Само-вызов (Self-Message, петля →⮌)
- Объект вызывает свой собственный метод.
- **Пример:**
```
[Order] →⮌ validate()  
```
---
#### ④ Условия и ветвления (Combined Fragments)
**Что это:** Логические блоки, которые показывают альтернативные сценарии.  
**Основные операторы:**
- **`opt` (опционально)** — выполняется при условии.
- **`alt` (альтернатива)** — if-else сценарий.
- **`loop` (цикл)** — повторение действия.

**Пример:**
```
alt [достаточно средств]  
  [PaymentGateway] → [Bank]: processPayment()  
else [недостаточно средств]  
  [PaymentGateway] → [User]: showError()  
```
---

#### ⑤ Создание/Уничтожение объектов
- **Создание:** Стрелка с надписью `«create»` (или пунктирная с `new`).
- **Уничтожение:** Крест (`X`) в конце линии жизни.

**Пример:**
```
[User] → [Order]: create()  
[Order] → X: cancel()  
```
---
### 3. Пример диаграммы (оформление заказа)


```plaintext
[Пользователь]       [OrderService]       [PaymentGateway]       [Database]
     |                     |                       |                 |
     |─────createOrder()───>|                      |                 |
     |                     |───checkStock()───────>|                 |
     |                     |<─────true─────────────|                 |
     |                     |───processPayment()───>|                 |
     |                     |<────success───────────|                 |
     |                     |───saveOrder()───────────────>|          |
     |<────Order Confirmed─|                       |                 |
```
**Пояснение:**
1. Пользователь вызывает `createOrder()`.
2. `OrderService` проверяет наличие товара (`checkStock()`).
3. Если товар есть, отправляет запрос на оплату (`processPayment()`).
4. После успешной оплаты сохраняет заказ в БД (`saveOrder()`).
5. Пользователь получает подтверждение.
---
### 4. Влияние на код
Диаграмма последовательности помогает:  
✅ Проектировать **логику методов** (например, в `OrderService`).  
✅ Определять **зависимости между классами** (вызовы `PaymentGateway`).  
✅ Оптимизировать **временные задержки** (асинхронные vs синхронные вызовы).
**Пример преобразования в код (Java):**

```java
class OrderService {
    public void createOrder(User user) {
        if (checkStock()) {           // Проверка наличия товара
            boolean paymentSuccess = PaymentGateway.processPayment();  
            if (paymentSuccess) {  
                Database.saveOrder(); // Сохранение заказа  
                user.notify("Order Confirmed");  
            }  
        }  
    }  
}  
```
---

### 5. Отличия от других диаграмм
- **vs Диаграмма классов:** Показывает не структуру, а **взаимодействие** объектов во времени.
- **vs Use Case Diagram:** Детализирует **один конкретный сценарий**, а не общую функциональность.

**Вывод:**  
Диаграмма последовательности — это «сценарий» работы системы, который превращается в код. Она незаменима для проектирования сложных процессов, API и микросервисов.

## Диаграмма деятельности (Activity Diagram): понятие и элементы

### 1. Суть диаграммы активности
Диаграмма активности (Activity Diagram) — это UML-диаграмма, которая визуализирует **поток действий** в системе или бизнес-процессе. Она показывает:
- **Последовательность шагов** (действий, операций).
- **Ветвления и условия** (принятие решений).
- **Параллельные процессы** (разделение и синхронизацию потоков).
- **Начало и конец процесса**.

Используется для:
- Моделирования **бизнес-процессов** (например, оформление заказа).
- Проектирования **алгоритмов** в программировании.
- Анализа **workflow** (например, согласование документов).
---
### 2. Обязательные элементы диаграммы активности
#### ① Действия (Actions)
**Что это:** Отдельные шаги процесса (например, _«Проверить наличие товара»_, _«Отправить уведомление»_).  
**Обозначение:** Прямоугольник со скругленными углами.  
**Пример:**
```
┌───────────────────┐  
│ Проверить запас   │  
└───────────────────┘  
```
#### ② Узлы управления (Control Nodes)

##### 1. Начало (Initial Node)
- Точка входа в процесс.  
    **Обозначение:** Черный кружок (●).
##### 2. Конец (Final Node)
- Точка завершения процесса.  
    **Обозначение:** Концентрический кружок (⓪).
##### 3. Ветвление (Decision Node)
- Разделение потока на условия (if-else).  
    **Обозначение:** Ромб (◆).  
    **Пример:**
```
           ◆  
         /   \  
[Да]  ──┤     ├── [Нет]  
         \   /  
```

##### 4. Слияние (Merge Node)
- Объединение альтернативных веток.  
    **Обозначение:** Ромб (◆).

##### 5. Разделение (Fork)
- Начало параллельных потоков.  
    **Обозначение:** Горизонтальная черта (───├───).

##### 6. Синхронизация (Join)
- Ожидание завершения всех параллельных потоков.  
    **Обозначение:** Горизонтальная черта (───┤───).
---

#### ③ Потоки управления (Control Flows)
**Что это:** Стрелки, соединяющие действия и узлы. Показывают направление процесса.  
**Пример:**
```
● → Действие 1 → ◆ → Действие 2 → ⓪  
```

#### ④ Дорожки (Swimlanes)
**Что это:** Разделение диаграммы на зоны ответственности (роли, отделы, системы).  
**Пример:**
```
┌───────────┬───────────┐  
│ Клиент    │ Система   │  
├───────────┼───────────┤  
│ Заполнить │ Проверить │  
│ заявку    │ данные    │  
└───────────┴───────────┘  
```
---
#### ⑤ Сигналы и события (Signals)
- **Отправка сигнала** (⬆): `Отправить email`.
- **Прием сигнала** (⬇): `Получить подтверждение`.
---

### 3. Примеры использования

#### Пример 1: Оформление заказа в интернет-магазине
```plaintext
● → [Выбрать товар] → [Добавить в корзину] → ◆  
                             │  
                   [Есть в наличии?]  
                          /     \  
                [Да] ── [Оплатить] → [Отправить заказ] → ⓪  
                [Нет] ─ [Уведомить клиента] → ⓪  
```
**Пояснение:**
1. Пользователь выбирает товар.
2. Система проверяет наличие.
3. Если товар есть — переход к оплате, если нет — уведомление.
---
#### Пример 2: Согласование документа в компании
```plaintext
┌───────────┬───────────┬───────────┐  
│ Автор     │ Руководитель │ Бухгалтерия │  
├───────────┼───────────┼───────────┤  
● → [Создать документ] → [Проверить] → ◆  
                             │  
                   [Одобрено?]  
                          /     \  
                [Да] ── [Подписать] → [Учет] → ⓪  
                [Нет] ─ [Вернуть на доработку] → ●  
```
**Пояснение:**
1. Автор создает документ.
2. Руководитель проверяет и принимает решение.
3. Если одобрено — документ подписывается и передается в бухгалтерию.
---
#### Пример 3: Параллельные процессы (запуск ракеты)
```plaintext
● → [Проверка топлива] → ├─── [Запуск двигателей] ───┤ → [Старт] → ⓪  
            ↑             └─── [Активация навигации] ─┘  
            └────────────── [Отмена при ошибке] → ⓪  
```
**Пояснение:**
- Два параллельных процесса (двигатели и навигация) должны завершиться перед стартом.
---
### 4. Применение в бизнес-анализе
Диаграмма активности помогает:  
✅ **Выявлять узкие места** (например, лишние шаги в согласовании).  
✅ **Стандартизировать процессы** (инструкции для сотрудников).  
✅ **Автоматизировать workflow** (например, в BPMN-системах).

**Отличие от BPMN:**
- UML-диаграмма активности — более общая, подходит для IT и бизнеса.
- BPMN — стандарт именно для бизнес-процессов (есть специфичные элементы, например, «задачи» вместо «действий»).
---
### 5. Вывод
Диаграмма активности — это «карта» процесса, которая:  
🔹 Упрощает понимание сложных сценариев.  
🔹 Показывает **что**, **кто** и **в каком порядке** делает.  
🔹 Преобразуется в **алгоритмы** (код) или **регламенты** (бизнес).
**Где использовать:**
- Разработка ПО (логика сервисов).
- Оптимизация бизнес-процессов (например, цепочки поставок).
- Обучение сотрудников (наглядные инструкции).
## Диаграмма состояний (State Machine Diagram): понятие и элементы

### 1. Суть диаграммы состояний
Диаграмма состояний (State Machine Diagram) — это UML-диаграмма, которая показывает **жизненный цикл объекта** через смену его состояний под воздействием событий. Она используется для моделирования
- Поведения сложных систем (например, workflow документов).
- Жизненных циклов объектов (заказ, пользователь, устройство).
- Конечных автоматов (FSM) в программировании.
**Ключевые особенности:**
- Фокусируется на **одном объекте** и его состояниях.
- Показывает, **какие события** вызывают переходы между состояниями.
- Может включать **действия** при входе/выходе из состояния.
---
### 2. Обязательные элементы диаграммы состояний

#### ① Состояния (States)

**Что это:** Стабильные условия объекта в определенный момент времени.  
**Виды состояний:**
- **Простое состояние** (например, `Неактивен`, `В обработке`).
- **Составное состояние** (содержит подсостояния, например, `Доставка` → `В пути`, `На складе`).
- **Начальное состояние** (черный кружок ●).
- **Конечное состояние** (концентрический кружок ⓪).
**Обозначение:**
```
┌─────────────────┐  
│   Состояние     │  
├─────────────────┤  
│ entry/действие  │  
│ exit/действие   │  
└─────────────────┘  
```
**Пример:**
```
┌─────────────────┐  
│    Заблокирован │  
├─────────────────┤  
│ entry/оповестить│  
└─────────────────┘  
```
---
#### ② Переходы (Transitions)

**Что это:** Изменение состояния под воздействием события.  
**Формат:**
```
[Триггер] [Условие] / [Действие]
```
- **Триггер** — событие, вызывающее переход (например, `onClick`).
- **Условие** (guard) — `[если баланс > 0]`.
- **Действие** — что выполняется при переходе (например, `/списать_средства`).

**Обозначение:** Стрелка с подписью.  
**Пример:**
```
[Оплата получена] → [Заказ подтвержден]
```
---
#### ③ События (Events)

**Типы событий:**
- **Внешние** (например, `Пользователь нажал кнопку`).
- **Внутренние** (например, `Таймер истек`).
- **Сигналы** (между объектами).

**Пример:**
```
[onPaymentSuccess] → Переход в состояние «Оплачено».
```
---
#### ④ Действия (Actions)
**Что это:** Операции, выполняемые:
- При входе в состояние (`entry/`).
- При выходе из состояния (`exit/`).
- Во время перехода (`/`).

**Пример:**
```
┌─────────────────┐  
│     Активен     │  
├─────────────────┤  
│ entry/логировать│  
│ exit/сохранить  │  
└─────────────────┘  
```
---

#### ⑤ Псевдосостояния

- **Ветвление (Decision Node)** — ромб (◆) для условий.
- **Слияние (Merge Node)** — объединение потоков.
- **История (H)** — возврат к последнему активному подсостоянию.

**Пример ветвления:**
```
           ◆  
         /   \  
[Да]  ──┤     ├──  [Нет]  
         \   /  
```
---

### 3. Примеры использования

#### Пример 1: Жизненный цикл заказа

Diagram
```Diagram
stateDiagram-v2
    [*] --> Создан
    Создан --> Подтвержден: [Оплата получена]
    Подтвержден --> В_доставке: [Передан курьеру]
    В_доставке --> Доставлен: [Клиент получил]
    В_доставке --> Отменен: [Клиент отказался]
    Доставлен --> [*]
    Отменен --> [*]
```
![[Pasted image 20250508181433.png]]
**Пояснение:**
- Заказ начинается в состоянии `Создан`.
- Переходит в `Подтвержден` после оплаты.
- Может быть отменен во время доставки.
---

#### Пример 2: Состояние пользователя в системе
```
● → Неактивен → Активен: [Вход в систему]  
Активен → Заблокирован: [3 ошибки пароля]  
Заблокирован → Активен: [Сброс пароля]  
Активен → ⓪: [Выход из системы]  
```
---

#### Пример 3: ATM (Банкомат)
```
stateDiagram-v2
    [*] --> Ожидание
    Ожидание --> Проверка_карты: [Вставлена карта]
    Проверка_карты --> Отказ: [Неверный PIN]
    Проверка_карты --> Меню: [Правильный PIN]
    Меню --> Выдача_наличных: [Выбрана опция]
    Меню --> Возврат_карты: [Отмена]
    Выдача_наличных --> Возврат_карты
    Возврат_карты --> Ожидание
```
![[Pasted image 20250508181659.png]]

---
### 4. Применение в сложных системах
- **Микросервисы:** Описание состояний платежа (`Создан` → `Обработан` → `Завершен`).
- **IoT:** Управление устройствами (`Выключен` → `Спящий режим` → `Активен`).
- **Игры:** Поведение персонажа (`Стоит` → `Бежит` → `Атакует`).

**Преимущества:**  
✅ Наглядность жизненного цикла объекта.  
✅ Простота выявления «мертвых» состояний.  
✅ Прямое преобразование в код (паттерн **State Machine**).

---
### 5. Отличие от других диаграмм
- **vs Диаграмма активности:**
    - Активность — **поток действий** (что делают разные объекты).
    - Состояния — **изменения одного объекта** (как он реагирует на события).
- **vs BPMN:**
    - BPMN — для бизнес-процессов с множеством участников.
    - Диаграмма состояний — для глубокого анализа поведения одного объекта.
**Вывод:**  
Диаграмма состояний — мощный инструмент для проектирования:  
🔹 Детерминированных систем (например, парсинг данных).  
🔹 Сложных объектов с множеством статусов (документы, заказы).  
🔹 Поведения, зависящего от событий (UI, игры).

**Пример кода (Python FSM):**
```python
class Order:
    def __init__(self):
        self.state = "Created"

    def pay(self):
        if self.state == "Created":
            self.state = "Confirmed"

    def cancel(self):
        if self.state in ["Created", "Confirmed"]:
            self.state = "Cancelled"
```
##  Диаграмма взаимодействия (Collaboration Diagram): суть и элементы

### 1. Суть диаграммы взаимодействия
Диаграмма взаимодействия (Collaboration Diagram) — это UML-диаграмма, которая показывает:
- **Какие объекты** участвуют в процессе.
- **Как они взаимодействуют** через сообщения.
- **Структуру связей** между объектами (ассоциации, агрегации).

**Отличия от диаграммы последовательности:**
- Акцент на **структуре связей**, а не на временной последовательности.
- Сообщения нумеруются (порядок выполнения виден через номера, а не через вертикальную временную шкалу).

**Где применяется:**
- Проектирование взаимодействия объектов в ООП.
- Анализ ролей в бизнес-процессах.
- Документирование API или микросервисов.
---

### 2. Обязательные элементы диаграммы
#### ① Объекты (Participants)**
**Что это:** Экземпляры классов, участвующие во взаимодействии.  
**Обозначение:** Прямоугольник с подписью в формате `имя:Класс`.  
**Пример:**
```
[order:Order]  
[user:Customer]  
```
---
#### ② Связи (Links)
**Что это:** Линии между объектами, показывающие их отношения (ассоциации, агрегации).  
**Обозначение:** Сплошная линия (───).  
**Пример:**
```
[user] ─── [order]  
```
---
#### ③ Сообщения (Messages)
**Что это:** Вызовы методов или сигналы между объектами.  
**Формат:**
```
[номер] : сообщение(параметры)  
```

- **Номер** — показывает порядок вызова (например, `1.1`, `2.3` для вложенных сообщений).
- **Стрелка** → для синхронных, ⤳ для асинхронных сообщений.

**Примеры:**
```
1: createOrder()  
2.1: validatePayment()  
```
---
#### ④ Нумерация сообщений
Иерархическая нумерация отражает вложенность вызовов:
- `1` — первое сообщение.
- `1.1` — подсообщение внутри `1`.
- `1.2` — следующее сообщение того же уровня.

**Пример:**
```
1: processOrder()  
  1.1: checkStock()  
  1.2: reserveItem()  
2: confirm()  
```

---

#### ⑤ Роли (Roles)
**Что это:** Назначение объекта в конкретном взаимодействии (например, «Инициатор», «Обработчик»).  
**Обозначение:** Подпись на связи.  
**Пример:**
```
[user] ─── «создатель» [order]  
```
---
### 3. Пример диаграммы (оформление заказа)
```plaintext
[user:Customer] ─── «создает» [order:Order]  
       | 1: createOrder()  
       | 2: addItem(item)  
       | 3: processPayment()  
       |  
[order] ─── «использует» [payment:PaymentGateway]  
       | 3.1: validateCard()  
       | 3.2: charge()  
       |  
[order] ─── «сохраняет» [db:Database]  
       4: save()  
```
**Пояснение:**
1. Пользователь создает заказ (`createOrder()`).
2. Добавляет товар (`addItem()`).
3. Инициирует оплату (`processPayment()`), что вызывает проверку карты и списание средств.
4. Заказ сохраняется в БД.
---
### 4. Как сделать диаграмму понятной для новичков

#### Правила оформления:
1. **Используйте простые имена** объектов (`user`, `order`, `payment`).
2. **Подписывайте роли** на связях («создает», «проверяет»).
3. **Группируйте сообщения** по этапам (например, `1-3` — создание заказа, `4-6` — оплата).
4. **Избегайте глубокой вложенности** (сообщения уровня `1.1.1` сложны для восприятия).
#### Пример для неподготовленных пользователей:
```plaintext
[Клиент] ─── «заказывает» [Заказ]  
    | 1: Выбрать товар()  
    | 2: Оплатить()  
    |  
[Заказ] ─── «проверяет» [Склад]  
    | 2.1: Наличие товара?()  
    |  
[Заказ] ─── «списывает» [Банк]  
    3: Списать деньги()  
```
---

### 5. Отличие от других диаграмм
- **vs Диаграмма последовательности:**
    - Collaboration — акцент на **связях объектов**, а не на времени.
    - Sequence — четкий порядок вызовов по вертикальной оси.
- **vs Диаграмма классов:**
    - Классы — статическая структура.
    - Collaboration — динамическое взаимодействие.
**Вывод:**  
Диаграмма взаимодействия полезна, когда нужно:  
✅ Показать **роли объектов** в процессе.  
✅ Увидеть **структуру связей** (например, какие сервисы вызывают друг друга).  
✅ Упростить сложные сценарии за счет нумерации сообщений.
**Пример преобразования в код (Java):**
```java
class Customer {
    void createOrder() {
        Order order = new Order();
        order.addItem(item);
        order.processPayment();
    }
}

class Order {
    void processPayment() {
        if (PaymentGateway.validateCard()) {
            PaymentGateway.charge();
            Database.save(this);
        }
    }
}
```

##  Диаграмма компонентов (Component Diagram): суть и элементы

### 1. Суть диаграммы компонентов  
Диаграмма компонентов — это **структурная UML-диаграмма**, которая показывает:
- **Компоненты** системы (модули, сервисы, библиотеки).
- **Интерфейсы**, через которые они взаимодействуют.
- **Зависимости** между компонентами.
**Цели:**
- Визуализация **архитектуры** системы на высоком уровне.
- Планирование **модульности** и повторного использования кода.
- Документирование **интеграции** между частями системы (например, микросервисами).
---

### 2. Обязательные элементы диаграммы
#### ① Компоненты (Components)
**Что это:** Логические или физические модули системы (например, веб-сервер, база данных, API).  
**Обозначение:** Прямоугольник с иконкой «компонента» (📦) и именем.  
**Пример:**
```
┌───────────────────┐  
│   OrderService    │  
└───────────────────┘  
```
**Виды компонентов:**
- **Исполняемые** (например, `BackendApp`).
- **Библиотеки** (например, `PaymentGatewayLib`).
- **Файлы** (например, `config.json`).
---
#### ② Интерфейсы (Interfaces)
**Что это:** Контракты, которые определяют, как компоненты взаимодействуют.  
**Типы:**
- **Предоставляемый интерфейс** (что компонент **предоставляет** другим).
    - Обозначение: кружок с линией (○──).
    - Пример: `OrderAPI` для сервиса заказов.
- **Требуемый интерфейс** (что компонент **ожидает** от других).
    - Обозначение: полукруг с линией (◡──).
    - Пример: `DatabaseConnector` для подключения к БД.
**Пример связи:**
```
┌─────────────┐                    ┌─────────────┐  
│ OrderService│ ○── OrderAPI ──◡   │PaymentService│  
└─────────────┘                    └─────────────┘  
```

---
#### ③ Зависимости (Dependencies)

**Что это:** Связи, показывающие, что один компонент использует другой.  
**Обозначение:** Пунктирная стрелка (⤳).  
**Пример:**
```
┌─────────────┐           ┌─────────────┐  
│  Frontend   │     ⤳    │   Backend    │  
└─────────────┘           └─────────────┘  
```

---
#### ④ Порт (Port)
**Что это:** Точка взаимодействия компонента с внешним миром.  
**Обозначение:** Квадратик на границе компонента (■).  
**Пример:**
```
┌───────────────────┐  
│   AuthService     │  
│ ■ ── login()      │  
└───────────────────┘  
```

---

#### ⑤ Соединители (Connectors)

**Что это:** Линии, связывающие порты или интерфейсы.  
**Обозначение:** Сплошная линия (──).  
**Пример:**
```
┌─────────────┐           ┌─────────────┐  
│  ClientApp  │ ────────  │ API Gateway │  
└─────────────┘           └─────────────┘  
```

---
### 3. Пример диаграммы (интернет-магазин)
```plaintext
┌───────────────────┐           ┌───────────────────┐  
│   UserService     │ ○──AuthAPI ──◡ │   AuthModule    │  
└───────────────────┘           └───────────────────┘  
       ︎│  
       ︎│ ⤳  
┌───────────────────┐           ┌───────────────────┐  
│  OrderService     │ ◡──PaymentAPI ○ │ PaymentGateway  │  
└───────────────────┘           └───────────────────┘  
       ︎│  
       ︎│ ⤳  
┌───────────────────┐  
│    Database       │  
└───────────────────┘  
```

**Пояснение:**
1. `UserService` предоставляет интерфейс `AuthAPI`, который использует `AuthModule`.
2. `OrderService` зависит от `PaymentGateway` через `PaymentAPI`.
3. Все сервисы сохраняют данные в `Database`.

---

### 4. Дополнительные элементы

#### ① Внутренняя структура компонента

Можно показать, из каких классов/модулей состоит компонент:
```
┌───────────────────┐  
│   OrderService    │  
├───────────────────┤  
│  - OrderValidator │  
│  - OrderProcessor │  
└───────────────────┘  
```

#### ② Стереотипы (Stereotypes)
Уточняют тип компонента:
- `<<API>>`, `<<Library>>`, `<<Database>>`.  
**Пример:**
```
┌───────────────────┐  
<<Microservice>>     │  
│   PaymentService  │  
└───────────────────┘  
```

---

### 5. Где применяется

#### Пример 1: Микросервисная архитектура
```
┌─────────────┐       ┌─────────────┐       ┌─────────────┐  
│  ClientApp  │ ⤳    │ API Gateway  │  ⤳   │ UserService │  
└─────────────┘       └─────────────┘       └─────────────┘  
                              ︎│  
                              ︎│ ⤳  
                   ┌─────────────┐       ┌─────────────┐  
                   │ OrderService│ ○───  │  PaymentDB  │  
                   └─────────────┘       └─────────────┘  
```

#### Пример 2: Мобильное приложение
```
┌─────────────┐       ┌─────────────┐  
│  MobileApp  │   ⤳  │  Backend     │  
└─────────────┘       └─────────────┘  
       ︎│                     ︎│  
       ︎│ ⤳                  ︎│ ⤳  
┌─────────────┐       ┌─────────────┐  
│  LocalDB    │       │ CloudStorage│  
└─────────────┘       └─────────────┘  
```

---

#### 6. Отличие от других диаграмм
- **vs Диаграмма классов:**
    - Классы — детали реализации, компоненты — высокоуровневые модули.
- **vs Диаграмма развертывания:**
    - Развертывание показывает физическое расположение компонентов на серверах.
**Вывод:**  
Диаграмма компонентов — это «карта» системы, которая:  
✅ Упрощает проектирование **сложных систем**.  
✅ Помогает разделять ответственность между **командами**.  
✅ Позволяет увидеть **точки интеграции** между модулями.
**Пример преобразования в код:**
```java
// OrderService (компонент)  
public class OrderService implements OrderAPI {  
    @Inject PaymentGateway paymentGateway; // зависимость  
    public void processOrder() { ... }  
}  

// PaymentGateway (внешний компонент)  
public interface PaymentAPI {  
    void charge();  
}

```
## Диаграмма развертывания (Deployment Diagram): суть и элементы

### 1. Суть диаграммы развертывания  
Диаграмма развертывания — это **UML-диаграмма**, которая показывает:
- **Физическое расположение** компонентов системы (серверы, устройства, сети).
- **Связи между узлами** (например, клиент-серверное взаимодействие).
- **Распределение артефактов** (программ, библиотек, конфигураций) по узлам.
**Цели:**
- Планирование **инфраструктуры** (например, облачные сервисы, локальные серверы).
- Документирование **топологии сети** и зависимостей между узлами.
- Оптимизация **производительности** и отказоустойчивости системы.
---
### 2. Обязательные элементы диаграммы

#### ① Узлы (Nodes)
**Что это:** Физические или виртуальные устройства, на которых развертываются компоненты.  
**Типы узлов:**
- **Устройство (Device)** — аппаратная единица (сервер, ПК, IoT-устройство).
    - Обозначение: 📦 с пометкой `<<device>>`.
    - Пример: `<<server>> Веб-сервер`, `<<database>> PostgreSQL`.
- **Среда исполнения (Execution Environment)** — программная платформа (контейнер, виртуальная машина).
    - Обозначение: 📦 с пометкой `<<executionEnvironment>>`.
    - Пример: `<<docker>> Контейнер API`, `<<jvm>> Сервис оплаты`.
**Пример:**
```
┌───────────────────┐  
<<device>>          │  
│   Cloud Server    │  
└───────────────────┘  
```
---
#### ② Артефакты (Artifacts)
**Что это:** Развертываемые компоненты (исполняемые файлы, библиотеки, конфиги).  
**Обозначение:** 📄 с именем артефакта.  
**Пример:**
```
┌───────────────────┐  
│ order-service.jar │  
└───────────────────┘  
```
---
#### ③ Связи (Connections)
**Что это:** Физические или логические соединения между узлами (сеть, протоколы).  
**Обозначение:** Сплошная линия с подписью протокола/технологии.  
**Пример:**
```
┌─────────────┐                   ┌─────────────┐  
│  Клиент     │ ───HTTP/HTTPS───  │  Веб-сервер │  
└─────────────┘                   └─────────────┘  
```
---
#### ④ Размещение артефактов на узлах
**Что это:** Показывает, какой артефакт выполняется на каком узле.  
**Обозначение:**
- Вложение артефакта в узел.
- Линия зависимости (⤳) от артефакта к узлу.
**Пример:**
```
┌───────────────────┐  
<<device>>          │  
│  AWS EC2          │  
├───────────────────┤  
│ order-service.jar │  
└───────────────────┘  
```
---
#### ⑤ Стереотипы и метки
Уточняют тип узла или связи:
- `<<database>>`, `<<loadBalancer>>`, `<<http>>`.  
**Пример:**
```
┌───────────────────┐  
<<cloud>>           │  
│   Kubernetes      │  
└───────────────────┘  
```

---
### 3. Пример диаграммы (веб-приложение)


```plaintext
┌───────────────────┐       ┌───────────────────┐  
<<device>>          │       <<device>>          │  
│  Пользователь     │ ───HTTP─── │  Веб-сервер  │  
└───────────────────┘       └───────────────────┘  
                                    |  
                                    | ⤳  
                    ┌───────────────────┐       ┌───────────────────┐  
                    <<executionEnvironment>>    │       <<device>>                              │  
                    │   Docker (API)    │ ───TCP─── │  База данных  │  
                    └───────────────────┘       └───────────────────┘  
                              |  
                              | ⤳  
                    ┌───────────────────┐  
                    │  payment-service  │  
                    └───────────────────┘  
```
**Пояснение:**
1. Пользователь взаимодействует с веб-сервером по HTTP.
2. Веб-сервер делегирует запросы API-контейнеру.
3. API подключается к базе данных и микросервису оплаты.

---
### 4. Важность каждого элемента

|**Элемент**|**Зачем включать?**|
|---|---|
|**Узлы**|Показывают, где работает система (облако, локальный сервер, мобильное устройство).|
|**Артефакты**|Уточняют, какие именно компоненты развернуты (версии ПО, конфигурации).|
|**Связи**|Объясняют, как узлы обмениваются данными (протоколы, сетевые задержки).|
|**Стереотипы**|Делают диаграмму читаемой (например, `<<kubernetes>>` vs `<<vm>>`).|

**Пример для DevOps:**  
Диаграмма помогает понять:
- Где развернут `order-service` (EC2, Kubernetes?).
- Как сервис оплаты (`payment-service`) подключается к БД (через VPN? REST?).

---
### 5. Отличие от других диаграмм
- **vs Диаграмма компонентов:**
    - Компоненты — логические модули, развертывание — физические узлы.
- **vs Диаграмма последовательности:**
    - Последовательность — временные взаимодействия, развертывание — статическая инфраструктура.
**Вывод:**  
Диаграмма развертывания — это «карта инфраструктуры», которая:  
✅ Показывает, **где** и **как** работает система.  
✅ Помогает выявлять **узкие места** в сети.  
✅ Упрощает **масштабирование** (добавление серверов, балансировщиков).
**Пример преобразования в код (Terraform):**
```hcl
resource "aws_instance" "web_server" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
}

resource "aws_db_instance" "database" {
  engine = "postgres"
}
```

## Диаграмма объектов
### Диаграмма объектов (Object Diagram) в UML

**Суть:**  
Диаграмма объектов — это структурная диаграмма UML, которая показывает **конкретный снимок системы в определенный момент времени**. Она отображает **экземпляры классов (объекты) и их связи** в реальном времени, помогая визуализировать состояние системы во время выполнения.

### Основные элементы:
1. **Объект (Object)**
    - Экземпляр класса, обозначается как:
        имяОбъекта : ИмяКласса  
    - Пример: `user1 : User`
    - Может быть анонимным (без имени): `:Order`
2. **Атрибуты (Slots)**
    - Текущие значения полей объекта.
    - Пример:
        account1 : Account  
        balance = 1500  
3. **Связи (Links)**
    - Экземпляры ассоциаций между объектами (как на диаграмме классов).
    - Обозначаются линией между объектами (иногда с ролью и кратностью).
    - Пример:
        `[customer]--[order]`
4. **Комментарии и ограничения** (по необходимости)
---

### Когда использовать?
- Для **демонстрации конкретного сценария** работы системы.
- Для **тестирования** корректности диаграмм классов.
- Для **объяснения сложных структур данных** на примере реальных объектов.


# Диаграммы проекта моделирование информационной системы управления конфликтами и претензиями в строительстве
Итак, в ходе работы над проектом моделирование системы предоставления управления конфликтами и претензиями в сфере строительства были определены прецеденты, актеры, классы и объекты системы и отношения между ними, описан поток событий основного прецедента, а также построены диаграммы прецедентов(рис. 1 и рис. 2), классов(рис.3), последовательности(рис. 4), деятельности(рис. 5), состояний, коопераций, компонентов и развертывания, которые приводятся ниже
## Диаграмма прецедентов
Для системы предоставления управления конфликтами и претензиями в сфере строительства мы определили *актеров* **Заказчик, Сотрудник, Исполнитель** и *прецеденты* **Составление заявления, Получение информации о заявлении, Статус заявления** 
![[Pasted image 20250508203747.png]]
**РИС.1 Основная диаграмма прецедентов**
Для прецедента **Составление заявления** мы построим доп. диаграмму вариантов использования 
![[Pasted image 20250508203812.png]]
**РИС.2 Дополнительная диаграмма прецедентов** 
## Диаграмма классов
Описывает работу классов между собой
![[Pasted image 20250509223004.png]]
**РИС.3 Диаграмма классов**
## Диаграмма последовательности
Пользователь выбирает опцию **"Разместить заявление"**, затем открывается форма ввода личных данных для регистрации в системе, в ней он вводит нужные данные для регистрации. Информация принимается и открывается форма для описание конфликта(претензии). Позже идет проверка точности введенных данных и после успеха выводит форму для подтверждения заявления. Объект **Заявление** обращается к объектам **Тип**, чтобы после присвоить определенный тип, а в конце пользователю отправляется форма для подтверждения оплаты.
![[Pasted image 20250511191602.png]]
**РИС.4 Диаграмма последовательности**
## Диаграмма деятельности
Данная диаграмма описывает взаимодействие между Пользователем системой и кредитной системой, данные действия происходят после того, как Пользователь нажал на кнопку оформить заявление
![[Pasted image 20250511221348.png]]
**РИС.5 Диаграмма деятельности**
## Диаграмма состояний
Заявление заполняется пользователем, затем **На проверке**, и вносится в список до того времени, пока не выполнятся заявления, которые впереди, в данном случае заявление принимает состояние **Ожидание** после выполнения, после его исполнения заявление примет значение **Решен**
![[Pasted image 20250512001959.png]]
**РИС. 6 Диаграмма состояний**
## Диаграмма коопераций
![[Pasted image 20250512011357.png]]
**РИС. 7 Диаграмма коопераций**
## Диаграмма компонентов
На диаграмме компонентов будет отображено взаимодействие и зависимости между  компонентами для того, чтобы понять как взаимодействуют разные системы друг с другом, что позволит лучше понять архитектуру и функциональность системы управления конфликтами и претензиями в строительстве.
![[Pasted image 20250513230400.png]]
**РИС. 8 Диаграмма компонентов**
## Диаграмма развертывания 
В данной диаграмме будет указано, как пользователь через сайт сможет подключится к серверному узлу через Интернет. А уже на сервере находится приложение, база данных и платежные шлюз, с помощью которого будет осуществляться проверки оплаты заявления 
![[Pasted image 20250513231545.png]]
**РИС.9 Диаграмма развертывания**
## Диаграмма объектов
Диаграмма объектов описывает, как пользователь взаимодействует с объектами класса оформление заявление, а оно в свою очередь показывает взаимодействия с ее классами. Благодаря ней можно понять, что к чему ведет при заполнении заявления пользователем
![[Pasted image 20250515104214.png]]
**РИС.10 Диаграмма объектов**
